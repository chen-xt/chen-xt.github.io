<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ajax详解</title>
    <url>/2016/08/21/Ajax%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax?"></a>什么是Ajax?</h2><p><strong>Ajax</strong> (Asynchronous JavaScript and XML)，是一种使网页实现异步更新的技术。Ajax的核心对象是<strong>XMLHttpRequest对象</strong>，XMLHttpRequest通过在后台与服务器进行少量数据交换，可以实现在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>传统的网页（不用Ajax技术的网页），想要更新内容或者提交一个表单，就要重新载入页面。而如果让网页使用Ajax技术，通过后台跟服务器进行少量的数据交换，网页就可以实现异步局部更新。我们身边有很多Ajax的应用案例，如新浪微博、开心网等等。</p>
<h2 id="Ajax的属性"><a href="#Ajax的属性" class="headerlink" title="Ajax的属性"></a>Ajax的属性</h2><p><strong>1. responseText属性：</strong>作为响应主体被返回的文本。</p>
<p><strong>2. responseXML属性：</strong>如果响应的内容类型是“text/xml”或“applocation/xml”，这个属性就将保存相应数据的XML DOM文档。</p>
<p><strong>3. status属性：</strong>响应的HTTP状态。只有当HTTP状态代码为200，才表示响应成功。此时可以访问responseText或者responseXML的内容。</p>
<p><strong>4. statusText属性：</strong>HTTP状态的说明。</p>
<p><strong>5. readyState属性：</strong>表示请求/响应过程的当前活动阶段。</p>
<ul>
<li>0：未初始化。还没有调用open()方法。</li>
<li>1：启动。已调用open()方法，还没有调用send()方法</li>
<li>2：发送。已调用send()方法，还没有接收到响应。</li>
<li>3：接收。已接收到部分响应数据。</li>
<li>4：（完成）已接收到全部响应数据，可以在客户端调用了。(此时仅代表完成（结束），是否成功还需要看status属性)</li>
</ul>
<h2 id="Ajax的使用"><a href="#Ajax的使用" class="headerlink" title="Ajax的使用"></a>Ajax的使用</h2><h4 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h4><p>创建XMLHttpRequest对象时需要考虑一个浏览器兼容性的问题，因为IE6及以下版本的浏览器不支持XMLHttpRequest对象，所以需要先检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject对象(IE6及以下版本的浏览器支持)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oAjax=<span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)         </span><br><span class="line">  &#123;</span><br><span class="line">      oAjax=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      oAjax=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h4><p>XMLHttpRequest对象连接服务器使用的是open()方法，它接受3个参数：要发送的请求的类型（“GET”或者“POST”）、请求的URL和表示是否异步发送请求的布尔值（“false”表示同步，“true”表示异步）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oAjax.open(<span class="string">&#x27;GET&#x27;</span>,”login.php”,<span class="literal">true</span>); </span><br></pre></td></tr></table></figure>
<p>这行代码会启动一个针对login.php的GET请求，且支持异步发送请求。使用open()方法并不会真正发送请求，而只是启动一个请求以备发送。</p>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>要真正发送特定的请求，需要在添加open()方法的基础上再添加send()方法。send()方法接受1个可选的参数，即要作为请求主体发送的数据。当发送的请求为POST请求时，必须使用 setRequestHeader() 来添加 HTTP 头，然后在 send() 方法中设置发送的数据。特别要注意的是，setRequestHeader() 方法必须在调用open(0方法之后且调用send()方法之前调用才可以成功发送头部信息。下面为一个POST请求的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oAjax.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;login.php&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">oAjax.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">oAjax.send(<span class="string">&quot;fname=Bill&amp;lname=Gates&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="接收返回"><a href="#接收返回" class="headerlink" title="接收返回"></a>接收返回</h4><p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。<br>只有当 readyState 等于 4 且状态为 200 时，才表示响应已就绪，而我们通常也只关注这2种状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oAjax.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(oAjax.readyState==<span class="number">4</span>)<span class="comment">//4表示（完成）响应内容解析完成，可以在客户端调用了</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span>(oAjax.status==<span class="number">200</span>)<span class="comment">//结果为200，代表成功</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="comment">//成功，服务器返回的内容</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="comment">//失败返回的内容                       </span></span><br><span class="line">                     </span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Ajax应用举例"><a href="#Ajax应用举例" class="headerlink" title="Ajax应用举例"></a>Ajax应用举例</h2><p>这里通过一个读取文件信息的Ajax小例子来加深对Ajax的理解。这个例子通过Ajax技术去读取文件名为“abc.txt”的文档里面的内容，并返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建ajax对象</span></span><br><span class="line"><span class="keyword">var</span> oAjax=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;</span><br><span class="line">    oAjax=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    oAjax=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.连接服务器  open(方法, url, 是否异步)</span></span><br><span class="line">oAjax.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&quot;abc.txt&quot;</span>,<span class="literal">true</span>);  <span class="comment">//异步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line">oAjax.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.接收返回</span></span><br><span class="line">oAjax.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(oAjax.readyState==<span class="number">4</span>)<span class="comment">//4表示（完成）响应内容解析完成，可以在客户端调用了</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(oAjax.status==<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            alert(<span class="string">&#x27;成功：&#x27;</span>+oAjax.responseText);<span class="comment">//服务器返回的内容  </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            alert(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title> Express中request对象参数获取</title>
    <url>/2016/11/19/Express%E4%B8%ADrequest%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;在表单类的操作中，客户端的HTTP请求通常会通过GET或POST提交一些数据到服务端，所以需要在服务端识别这些数据并进行处理。常利用request对象的三个方法来进行操作。</p>
<h2 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h2><p>&emsp;&emsp;获取请求路径。</p>
<ul>
<li>例1<pre><code> 浏览器访问：localhost:3000/login
 服务端侦听：app.use(&#39;/:key&#39;,function(req,res)&#123;&#125;);
 则：req.params.key为login。</code></pre>
</li>
<li>例2<pre><code> 浏览器访问：localhost:3000/user/tom
 服务端侦听：app.use(&#39;/user/:name&#39;,function(req,res)&#123;&#125;);
 则：req.params.name为tom。</code></pre>
</li>
</ul>
<h2 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h2><p>&emsp;&emsp;获取GET请求的参数（即地址栏传递的参数）。</p>
<ul>
<li>例<pre><code>浏览器访问：http://localhost:3000/login?username=Tom&amp;&amp;password=123
服务端侦听：app.use(&#39;/:key&#39;,function(req,res)&#123;&#125;);
则：req.query.usename和req.query.password分别为Jack和123。</code></pre>
</li>
</ul>
<h2 id="req-body"><a href="#req-body" class="headerlink" title="req.body"></a>req.body</h2><p>&emsp;&emsp;获取POST请求的参数。</p>
<ul>
<li>例<pre><code>浏览器访问：http://localhost:3000/login，通过表单POST参数username=Tom &amp;&amp; password=123
服务端侦听：app.use(&#39;/:key&#39;,function(req,res)&#123;&#125;);
则：req.body.usename和req.body.password分别为Tom和123。</code></pre>
</li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li>req.params和req.query的主要区别：<br>  req.params包含路由参数（在URL的路径部分），而req.query包含URL的查询参数（在URL的？后的参数）。</li>
<li>req.param()方法已经被弃用。</li>
</ol>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的基本使用</title>
    <url>/2016/09/28/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。在使用Git之前，你需要去<a href="https://github.com/">github官网</a>去注册个账号。</p>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>Git的安装很简单，直接<a href="https://git-for-windows.github.io/">下载</a>一个git安装包，然后安装的时候一直next到finish就OK了。<br>Git安装完成后需要做要一下设置，设置<code>username</code>和<code>email</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;your name&quot;  </span><br><span class="line">  &#x2F;&#x2F;your name为github注册的名字</span><br><span class="line">$ git  config --global user.email &quot;your_email@youremail.com&quot; </span><br><span class="line">  &#x2F;&#x2F;your_email@youremail.com为github注册的邮箱</span><br></pre></td></tr></table></figure>

<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<ol>
<li>选择一个合适的地方，创建一个空目录<code>source</code>(版本库的名字可以随意取)，在我电脑上，我的仓库位于<code>E:\source</code>。</li>
<li>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库。执行完命令后可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，所以没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li>
<li>添加文件到Git仓库，需要两步(这里以test.md文件为例)：</li>
</ol>
<ul>
<li>第一步，使用命令<code>git add &lt;file&gt;</code>，将文件test.md添加到仓库：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add test.md</span><br></pre></td></tr></table></figure>
 这个命令可反复多次使用，添加多个文件。</li>
<li>第二步，使用命令<code>git commit -m “xxx”</code>，其中<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，不添加说明也是可以的。通过这个命令将文件提交到仓库：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;test1&quot;</span><br><span class="line">[master 2140772] test1</span><br><span class="line">1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这个时候，问题来了：为什么Git添加文件需要<code>add</code>、<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt </span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;  &#x2F;&#x2F;2个文件都被提交 </span><br><span class="line">         </span><br></pre></td></tr></table></figure>

<h2 id="管理文件"><a href="#管理文件" class="headerlink" title="管理文件"></a>管理文件</h2><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p><code>Cat</code>命令可以查看文件的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.md</span><br><span class="line">hello！</span><br></pre></td></tr></table></figure>
<p>上面的命令告诉我们test.md文件的内容为<code>hello！</code>。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>git rm</code>命令可以删除文件，它有2种删除方式。先新建一个文件，命名为delete.md，然后通过<code>git rm</code>命令的2种方式来删除该文件。<br>（1） <code>git rm &lt;file&gt;</code> 从暂存区和仓库中都删除某文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm delete.md</span><br><span class="line">  rm &#39;delete.md&#39;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;del1&quot;</span><br><span class="line"> [master 25d0ea2] del1</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 delete.md</span><br></pre></td></tr></table></figure>
<p>执行上面的命令后，会删除文件跟踪并且删除仓库中的文件delete.md，当你提交删除动作后，git不再管理该文件。去查看本地仓库，发现delete.md文件已经不存在了。</p>
<p>（2） <code>git rm --cached &lt;file&gt;</code>从暂存区删除某文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm --cached delete.md</span><br><span class="line">   rm &#39;delete.md&#39;</span><br><span class="line">     </span><br><span class="line">$ git commit -m &quot;del2&quot;</span><br><span class="line">[master 5deede4] del2</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 delete.md</span><br></pre></td></tr></table></figure>
<p>执行上面的命令后，删除文件跟踪但不删除仓库的文件delete.md，当你提交删除动作后，git不再管理该文件，但是文件系统中还是有delete.md文件。查看本地仓库，发现delete.md文件还是存在的。</p>
<h2 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h2><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，修改test.md的内容，执行该命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>上面的命令告诉我们，test.md文件被修改过了，但还没有准备提交修改。接下来我们可以使用<code>git diff</code>命令来查看具体修改的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a&#x2F;test.md b&#x2F;test.md</span><br><span class="line">index bc7774a..0000000</span><br><span class="line">--- a&#x2F;test.md</span><br><span class="line">+++ b&#x2F;test.md</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello！</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+hello world！</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>
<p>上面的命令告诉我们，test.md文件原本内容是<code>hello!</code>,现在被修改为<code>hello world！</code>。只要再使用<code>git add</code>和<code>git commit</code>两个命令即可完成修改文件的提交。</p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>刚才我们对test.md文件进行了1次修改,为了能够有个明显的对照，再次对test.md进行一次修改(将内容<code>hello world！</code>改为<code>world!</code>)。也就是说，现在仓库里保存着test.md的3个版本，可以通过<code>git log</code>命令查看从最近到最远的提交日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit f11d47a998c6b66bf6ee6b2ba0ad41b3bbf1af7a</span><br><span class="line">Author: chen-xt &lt;1250548605@qq.com&gt;</span><br><span class="line">Date:   Tue Sep 27 21:25:27 2016 +0800</span><br><span class="line"></span><br><span class="line">    test3</span><br><span class="line"></span><br><span class="line">commit 41b8298cff37c388eaba6a36822daf39e012968f</span><br><span class="line">Author: chen-xt &lt;1250548605@qq.com&gt;</span><br><span class="line">Date:   Tue Sep 27 21:23:30 2016 +0800</span><br><span class="line"></span><br><span class="line">    test2</span><br><span class="line"></span><br><span class="line">commit 21407720a1f2e4cf53a1c79f943b43b057eccd2f</span><br><span class="line">Author: chen-xt &lt;1250548605@qq.com&gt;</span><br><span class="line">Date:   Tue Sep 27 21:21:03 2016 +0800</span><br><span class="line"></span><br><span class="line">test1</span><br></pre></td></tr></table></figure>
<p>从提交日志中我们可以看到3次提交，最近的一次是test3，上一次是test2，最早的一次是test1，而跟在commit后面的一大串类似21407720a…的是<code>commit id</code>（版本号)。</p>
<h3 id="回退过去"><a href="#回退过去" class="headerlink" title="回退过去"></a>回退过去</h3><p>现在是在版本test3，而如果我们想退回上一个版本，也就是test2，那么可以怎么做呢？只要一句命令<code>$ git reset --hard HEAD^</code>即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 41b8298 test2</span><br></pre></td></tr></table></figure>
<p>此时再查看日志，可以看到test3版本已经不存在了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 41b8298cff37c388eaba6a36822daf39e012968f</span><br><span class="line">Author: chen-xt &lt;1250548605@qq.com&gt;</span><br><span class="line">Date:   Tue Sep 27 21:23:30 2016 +0800</span><br><span class="line"></span><br><span class="line">    test2</span><br><span class="line"></span><br><span class="line">commit 21407720a1f2e4cf53a1c79f943b43b057eccd2f</span><br><span class="line">Author: chen-xt &lt;1250548605@qq.com&gt;</span><br><span class="line">Date:   Tue Sep 27 21:21:03 2016 +0800</span><br><span class="line"></span><br><span class="line">    test1</span><br></pre></td></tr></table></figure>
<p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<h3 id="重返未来"><a href="#重返未来" class="headerlink" title="重返未来"></a>重返未来</h3><p>（1） 命令行窗口未关掉<br>如上现在处于版本test2，如果想回去刚最新的版本又该如何呢？办法还是有的，只要你上面的命令行窗口还没有被关掉，就可以找到test3版本的版本号<code>f11d47a998c6b66bf6ee6b2ba0ad41b3bbf1af7a</code>，那么使用如下命令即可回去最新的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard f11d47a998</span><br><span class="line">HEAD is now at f11d47a test3</span><br></pre></td></tr></table></figure>
<p>如上命令所示，现在处于版本test3，命令中版本号不需要写全，只需要前面几位即可，Git会自动去找。</p>
<p>（2） 命令行窗口已关掉<br>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令，所以如果命令行已经关掉的话，可以通过这个命令来找回要回去的版本号，然后再执行命令<code>$ git reset --hard commit-id</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">f11d47a HEAD@&#123;0&#125;: reset: moving to f11d47a998</span><br><span class="line">41b8298 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">f11d47a HEAD@&#123;2&#125;: commit: test3</span><br><span class="line">41b8298 HEAD@&#123;3&#125;: commit: test2</span><br><span class="line">2140772 HEAD@&#123;4&#125;: commit: test1</span><br></pre></td></tr></table></figure>

<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="在GitHub创建一个Git仓库"><a href="#在GitHub创建一个Git仓库" class="headerlink" title="在GitHub创建一个Git仓库"></a>在GitHub创建一个Git仓库</h3><p>登录<a href="https://github.com/">GitHub</a>，然后，在右上角找到<code>Create a new repo</code>按钮，创建一个新的仓库，命名为<code>source</code>。</p>
<h3 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h3><p>（1） 在本地创建ssh key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure>
<p>其中<code>your_email@youremail.com </code>改为你的邮箱，也是在github上注册的那个邮箱。</p>
<p>（2） 接下来就是回车回车，直到出现命令完成，提示可以进行下一条命令。</p>
<p>（3） 打开<code>.ssh</code>文件，打开<code>id_rsa.pub</code>，复制里面的key。里面的key是一对看不懂的字符数字组合，不用管它，直接复制。</p>
<p>（4） 回到github网站，进入<code>Account Settings</code>，左边选择<code>SSH Keys</code>，<code>Add SSH Key</code>，title随便填，在key里粘贴刚copy的那一段看不懂的字符。</p>
<p>（5） 验证是否成功，在<code>git bash</code>下输入<code>$ ssh -T git@github.com</code>。出现<code>Are you sure you want to continue connecting (yes/no)? </code>填<code>yes</code>。回车就会看到：<code>You’ve successfully authenticated, but GitHub does not provide shell access</code>。这就表示已成功连上github。刷新github网站，会发现<code>ssh key</code> 的钥匙标志由灰色变成绿色。</p>
<h3 id="把本地仓库的内容推送到GitHub仓库"><a href="#把本地仓库的内容推送到GitHub仓库" class="headerlink" title="把本地仓库的内容推送到GitHub仓库"></a>把本地仓库的内容推送到GitHub仓库</h3><p>使用<code>$ git remote add origin git@github.com:yourName/yourRepo.git</code>命令关联一个远程库。其中<code>yourName</code>和<code>yourRepo</code>表示你在github的用户名和刚才新建的仓库，推送完之后进入.git文件夹，打开config文件，这里会多出一个<code>remote “origin”</code>内容，这就是刚才添加的远程地址，也可以直接修改config文件来配置远程地址。</p>
<h3 id="把本地仓库的所有内容推送到远程库上"><a href="#把本地仓库的所有内容推送到远程库上" class="headerlink" title="把本地仓库的所有内容推送到远程库上"></a>把本地仓库的所有内容推送到远程库上</h3><p>推送的前提是文件已经被添加到本地仓库，也就是说已经<code>git add</code>和<code>git commit</code>操作了。<br>使用<code>git push origin master</code>命令将文件推送到远程库上。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。<br><em>注意</em>：由于远程库是空的，我们第一次推送master分支时，加上了<code>-u</code>参数，也就是使用<code>git push -u origin master</code>Git不但会把本地的<code>master</code>分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送时就可以省去<code>-u</code>参数。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML媒体捕获实例</title>
    <url>/2018/11/06/HTML%E5%AA%92%E4%BD%93%E6%8D%95%E8%8E%B7%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="accept属性"><a href="#accept属性" class="headerlink" title="accept属性"></a>accept属性</h2><p>&emsp;&emsp;规定了可通过文件上传提交的服务器接受的文件类型，仅适用于<code> &lt;input type=&quot;file&quot;&gt;</code>。</p>
<ol>
<li><code> audio/*</code> ：接受所有的声音文件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;audio&#x2F;*&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><code> video/*</code> ：接受所有的视频文件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;video&#x2F;*&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><code> image/*</code> ：接受所有的图像文件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;image&#x2F;*&quot;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="capture属性"><a href="#capture属性" class="headerlink" title="capture属性"></a>capture属性</h2><p>&emsp;&emsp;可以捕获到系统默认的设备。</p>
<ol>
<li><code> camera</code> ：照相机。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;image&#x2F;*&quot; capture&#x3D;&quot;camera&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><code> camcorder</code> ：摄像机。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;video&#x2F;*&quot; capture&#x3D;&quot;camcorder&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><code> microphone</code> ：录音。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;audio&#x2F;*&quot; capture&#x3D;&quot;microphone&quot;&gt;</span><br></pre></td></tr></table></figure>
&emsp;&emsp;注：<code>input:file</code>标签有个<code>multiple</code>属性，表示可以支持多选。加了这个属性，<code>capture</code>就没效果了。</li>
</ol>
<h2 id="常见例子"><a href="#常见例子" class="headerlink" title="常见例子"></a>常见例子</h2><ol>
<li>调用拍照：微信环境及浏览器环境下，苹果手机、安卓手机均可以拍照。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type &#x3D;”file”  accept &#x3D;”image &#x2F; *”  capture&gt;</span><br></pre></td></tr></table></figure></li>
<li>调用录像：微信环境及浏览器环境下，苹果手机、安卓手机均可以录像。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type &#x3D;”file”  accept &#x3D;”video &#x2F; *”  capture&gt;</span><br></pre></td></tr></table></figure></li>
<li>调用音频：微信环境，苹果手机、安卓手机均可以调起录音机和文件；浏览器环境，苹果手机、安卓手机均只能调起录音机。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type &#x3D;”file”  accept &#x3D;”audio &#x2F; *”  capture&gt;</span><br></pre></td></tr></table></figure></li>
<li>高级用例：在标记中指定capture属性，并通过XMLHttpRequest在脚本中处理文件上载。微信环境及浏览器环境下，苹果手机、安卓手机均可以拍照。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type &#x3D;”file”  accept &#x3D;”image &#x2F; *”  capture&gt;</span><br></pre></td></tr></table></figure></li>
<li>无capture：微信环境，苹果手机、安卓手机均可以调起拍照和文件；浏览器环境，苹果手机可以调起拍照和相册，安卓手机可以调起拍照和文件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type &#x3D;”file”  accept &#x3D;”image &#x2F; *”&gt;</span><br></pre></td></tr></table></figure></li>
<li>无capture：微信环境，苹果手机、安卓手机均可以调起文件；浏览器环境，苹果手机可以调起拍照、相册和文件，安卓手机可以调起拍照和文件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type &#x3D;”file”&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="浏览器环境判断"><a href="#浏览器环境判断" class="headerlink" title="浏览器环境判断"></a>浏览器环境判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ua &#x3D; navigator.userAgent.toLowerCase();&#x2F;&#x2F;获取浏览器的userAgent</span><br><span class="line">if(ua.match(&#x2F;MicroMessenger&#x2F;i) &#x3D;&#x3D; &quot;micromessenger&quot;) &#123;</span><br><span class="line">    &#x2F;&#x2F; true为微信环境</span><br><span class="line">    alert(&quot;微信环境&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">   &#x2F;&#x2F; false为浏览器环境</span><br><span class="line">    alert(&quot;浏览器环境&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="苹果、安卓设备判断"><a href="#苹果、安卓设备判断" class="headerlink" title="苹果、安卓设备判断"></a>苹果、安卓设备判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   var ua &#x3D; navigator.userAgent.toLowerCase();&#x2F;&#x2F;获取浏览器的userAgent</span><br><span class="line">var isIos &#x3D; (ua.indexOf(&#39;iphone&#39;) !&#x3D; -1) || (ua.indexOf(&#39;ipad&#39;) !&#x3D; -1);</span><br><span class="line">   if (isIos) &#123;</span><br><span class="line">       &#x2F;&#x2F;true为苹果</span><br><span class="line">   alert(&quot;苹果手机&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else&#123;</span><br><span class="line">       &#x2F;&#x2F; false为安卓</span><br><span class="line">       alert(&quot;安卓手机&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><ul>
<li><a href="http://anssiko.github.io/html-media-capture/">参考网址1</a></li>
<li><a href="https://blog.csdn.net/bbt_yyc/article/details/78337501">参考网址2</a></li>
</ul>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之JSON</title>
    <url>/2016/08/19/JS%E4%B9%8BJSON/</url>
    <content><![CDATA[<p><strong>JSON</strong>(JavaScript Object Notation，JavaScript对象表示法)，是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON的语法可以有3种类型的值：简单值、对象和数组。</p>
<h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><p>简单值是最简单的JavaScript数据形式。在JSON中可以表示字符串、数值、布尔值和null，比如可以表示字符串：”good night”，但是JSON不支持JavaScript中的特殊值undefined。<br>注意：JSON字符串必须使用双引号(单引号会导致语法错误)，这是JSON字符串与JavaScript字符串的最大区别。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JSON对象同JavaScript对象字面量相似，但是也有两点不同之处：(1)JSON对象没有声明变量，因此JSON中没有变量的概念。(2)JSON没有末尾的分号。JSON对象允许对象中嵌入对象。<br>注意：对象的属性必须加双引号；同一个对象中绝不能出现两个同名属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “name”:”rose”,</span><br><span class="line">    “age”:<span class="number">20</span>,</span><br><span class="line">    “school”:&#123; <span class="comment">//对象中嵌套对象</span></span><br><span class="line">        “name”:”WuYi College”,</span><br><span class="line">        “location”:”NanPing”  <span class="comment">//没有末尾的分号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSON数组采用的是JavaScript中的数组字面量形式。比如：[23,”hello”,false]。<br>注意，JSON数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    “name”:”rose”,</span><br><span class="line">    “age”:<span class="number">20</span>,</span><br><span class="line">    “school”:[</span><br><span class="line">    ”WuYi College”</span><br><span class="line">    ]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><p>JSON可以把JSON数据结构解析为有用的JavaScript对象，这是其一大优势。通过两个方法JSON对象可以对JavaScript对象进行序列化和解析：</p>
<ul>
<li>stringify()方法：把JavaScript对象序列化为JSON字符串。在序列化JavaScript对象时，所有函数及原型成员都会被忽略，值为undefined的任何属性也会被跳过。</li>
<li>parse()方法：把JSON字符串解析原生JavaScript值。</li>
</ul>
<h3 id="stringify-方法"><a href="#stringify-方法" class="headerlink" title="stringify()方法"></a>stringify()方法</h3><p>JSON. stringify()方法接收3个参数：①要序列化的对象；②过滤器，可以是一个数组或一个函数(替换(过滤)函数)；③一个选项，表示是否在 JSON字符串中保留缩进。</p>
<h4 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h4><p>(1) 过滤器参数为数组：<br>JSON. stringify()的结果中将只包含数组中列出的属性。看下面一个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var person=&#123;</span><br><span class="line">    &quot;name&quot;:&quot;rose&quot;,</span><br><span class="line">    &quot;age&quot;:20,</span><br><span class="line">    &quot;school&quot;:[</span><br><span class="line">        &quot;WuYi College&quot;</span><br><span class="line">    ]</span><br><span class="line">    &#125;</span><br><span class="line">    var jsonText = JSON.stringify(person,[&quot;name&quot;,&quot;age&quot;]);</span><br></pre></td></tr></table></figure>
<p>如上面的例子，JSON. stringify()的第二个参数是一个数组，包含name和age两个属性，所以在返回的结果字符串中，就只会包含这两个属性，序列化的结果如下：{“name”:”rose”,“age”:20}。<br>(2) 过滤器参数为函数：<br>传入的函数接收2个参数：属性(键)名和属性值。函数返回的值就是相应键的值，当函数返回了undefined，那么相应的属性会被忽略。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var person=&#123;</span><br><span class="line">    &quot;name&quot;:&quot;rose&quot;,</span><br><span class="line">    &quot;age&quot;:20,</span><br><span class="line">    &quot;school&quot;:[</span><br><span class="line">        &quot;WuYi College&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">var jsonText = JSON.stringify(person,function(key,value)&#123;</span><br><span class="line"> switch(key)&#123;</span><br><span class="line">                case &quot;name&quot;:</span><br><span class="line">                  return value.join(&quot;,&quot;)</span><br><span class="line">                case &quot;age&quot;:</span><br><span class="line">                  return 25;</span><br><span class="line">                case &quot;school&quot;:</span><br><span class="line">                  return undefined;</span><br><span class="line">                default:</span><br><span class="line">                  return value;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的例子中，如果键为”name”，就将数组连接为一个字符串；如果键为 “age”，则将其值设置为25；如果键为”school”，通过返回undefined删除该属性。最后，提供一个default项，返回传入的值。序列化的结果如下：{“name”:”rose”,”age”:25,}。</p>
<h4 id="字符串缩进"><a href="#字符串缩进" class="headerlink" title="字符串缩进"></a>字符串缩进</h4><p>JSON. stringify()的第3个参数用于控制结果中缩进和空白符，它的类型有2种：数值和字符串。<br>(1) 参数是数值<br>数值表示的是每个级别缩进的空格数。但是缩进的空格数是有限制的，最大缩进空格数为10，所以大于10的值都会自动转换为10。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(person, <span class="literal">null</span>, <span class="number">3</span>);<span class="comment">//每个级别缩进3个空格</span></span><br></pre></td></tr></table></figure>
<p>(2) 参数是字符串<br>字符串将在JSON字符串中被用作缩进字符，不再使用空格。同样的，字符串的长度也是有限制的，最长不能超过10，一旦超过，只会显示前10个字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(person, <span class="literal">null</span>, <span class="string">&quot;--&quot;</span>);<span class="comment">//每个级别缩进两个短划线</span></span><br></pre></td></tr></table></figure>

<h3 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse()方法"></a>parse()方法</h3><p> JSON. parse()方法接收2个参数：①要序列化的对象；②一个函数(还原函数)。<br>传入的函数接收2个参数：属性(键)名和属性值。函数返回的值就是相应键的值。当函数返回了undefined，那么相应的属性会被删除；当函数返回其他值，则将该值插入到结果中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var person=&#123;</span><br><span class="line">    &quot;name&quot;:&quot;rose&quot;,</span><br><span class="line">    &quot;age&quot;:20,</span><br><span class="line">    &quot;school&quot;:[</span><br><span class="line">        &quot;WuYi College&quot;</span><br><span class="line">    ],</span><br><span class="line">    releaseDate: new Date(2016,8,18) </span><br><span class="line">   &#125;</span><br><span class="line">var jsonText = JSON.stringify(person);</span><br><span class="line"></span><br><span class="line">var personCopy = JSON.parse(jsonText,function(key,value)&#123;</span><br><span class="line">      if (key == &quot;releaseDate&quot;)&#123;</span><br><span class="line">                return new Date(value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    alert(personCopy.releaseDate.getFullYear());//2016</span><br></pre></td></tr></table></figure>
<p>如上面的例子，先为person对象新增一个releaseDate属性，该属性保存一个Date对象，这个对象经过序列化后变成有效的JSON字符串，然后经过解析又在 personCopy中还原为一个Date对象。还原对象在遇到”releaseDate”键时，会基于相应的值创建一个新的Date对象。结果就是personCopy.releaseDate属性中会保存一个Date对象，因此才能调用getFullYear()方法。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之事件</title>
    <url>/2016/08/07/JS%E4%B9%8B%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>什么是事件呢？用户在某些内容上的点击、鼠标经过某个特定元素或按下键盘上的某些按键等等这些都算是事件。所以说白点，事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流是从页面中接收事件的顺序。主要有IE提出的事件冒泡流和Netscape开发团队提出的事件捕获流。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点(文档)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>事件冒泡<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">”div1”</span>&gt;</span>传播顺序为：<span class="tag">&lt;<span class="name">div</span>&gt;</span>,<span class="tag">&lt;<span class="name">body</span>&gt;</span>,<span class="tag">&lt;<span class="name">html</span>&gt;</span>,document <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上的例子，click事件首先在div元素(我们单击的元素)上发生，然后，click事件沿DOM树向上传播，在每一级节点都会发生，直至传播到document对象。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获，即不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>事件冒泡<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">”div1”</span>&gt;</span>传播顺序为：document,<span class="tag">&lt;<span class="name">html</span>&gt;</span>,<span class="tag">&lt;<span class="name">body</span>&gt;</span>,<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上的例子，document对象首先接收到clcik事件，然后事件沿DOM树依次向下，一直传播到事件的实际目标，即div元素。</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM事件流包括三阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会；然后是实际的目标接收到事件；最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>产生了事件，我们就要去处理他，因此需要事件处理程序，即响应某个事件的函数。主要有以下几种方式：</p>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><p>HTML事件处理程序：直接在HTML代码中添加事件处理程序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;Hello world!&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;showMessage()&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码中，我们可以看出，事件处理是直接嵌套在元素里头的，这样有一个缺点就是html和js代码紧密耦合，如果要更换事件处理程序，不但要修改js，还需要修改html。一两处修改尚可接受，当你的代码达到万行级别时，修改起来就将会是件工程量浩大的事情了。因此并不推荐使用。</p>
<h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>DOM0级事件处理程序：为指定对象添加事件处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"> btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.id);</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中，我们能看出，相对于HTML事件处理程序，DOM0级事件处理程序中html代码和js代码的耦合性已经大大降低。</p>
<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>DOM2级事件处理程序：也是对特定的对象添加事件处理程序。定义了两个方法addEventListener()和removeEventListener()，用于处理指定和删除事件处理程序的操作。它们都接收三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值（是否在捕获阶段处理事件）。</p>
<ol>
<li>addEventListener()方法：添加事件处理程序。使用该方法的一个好处就是可以添加多个事件处理程序。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">  btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.id);</span><br><span class="line">        &#125;, <span class="literal">false</span>); <span class="comment">//false，表示在冒泡阶段调用事件处理程序</span></span><br><span class="line"> btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
上面的代码为一个按钮添加了两个事件处理程序，这两个事件处理程序会按照添加它们的<strong>顺序触发</strong>，因此首先会显示元素的ID，其次会显示“Hello world!”消息。</li>
<li>removeEventListener()方法：删除通过addEventListener()方法添加的事件处理程序，删除时传入的参数必须与添加处理程序时使用的参数相同，也就是说，无法删除匿名函数。我们来看一个例子：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">  btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.id);</span><br><span class="line">        &#125;, <span class="literal">false</span>); </span><br><span class="line">btn.removeEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.id);</span><br><span class="line">        &#125;, <span class="literal">false</span>);  <span class="comment">//无法删除</span></span><br></pre></td></tr></table></figure>
上面的代码，我们使用addEventListener()添加了一个事件处理程序，虽然调用removeEventListener()时看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中那个是完全不同的函数，所以没办法删除。那么应该如何进行改进，才能使removeEventListener()发挥其真正的作用呢？<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.id);</span><br><span class="line">        &#125;;</span><br><span class="line">        btn.addEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> removeBtn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myRemoveBtn&quot;</span>);</span><br><span class="line">        removeBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            btn.removeEventListener(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);  <span class="comment">//成功删除        </span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
上述重写后的例子，在addEventListener()和removeEventListener()中使用了相同的函数，因此，成功地删除所添加的事件处理程序。<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3>IE实现了与DOM类似的两个方法：attachEvent()和detachEvent()方法，它们都接受两个参数，事件处理程序名称与事件处理程序函数。</li>
<li>attachEvent()方法：添加事件处理程序。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
上述例子，使用attachEvent()方法添加了一个事件处理程序，需要注意的一点是，attachEvent()第一个参数是“onclick”，而addEventListener()方法中是“click”。同样的，attachEvent()方法也可以用来添加多个事件处理程序，只是触发顺序是<strong>逆序</strong>的，与addEventListener()多事件处理程序的触发顺序相反。</li>
<li>detachEvent()方法：删除通过attachEvent()方法添加的事件处理程序，条件是必须提供相同的参数，同样的，detachEvent()方法无法删除匿名函数。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"> <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">  btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, handler);     </span><br><span class="line"> <span class="keyword">var</span> removeBtn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myRemoveBtn&quot;</span>);</span><br><span class="line">  removeBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    btn.detachEvent(<span class="string">&quot;onclick&quot;</span>, handler); </span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
上述例子，首先利用attachEvent()方法成功添加一个事件处理程序，然后利用detachEvent()删除所添加的事件处理程序。<h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3>综合前面所提到的几种事件处理程序方法，我们封装一个EventUtil对象，实现跨浏览器处理事件。如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;  <span class="comment">//添加事件</span></span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;  <span class="comment">//删除事件</span></span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
上述两个方法首先都会检测传入的元素中是否存在DOM2级方法。如果存在DOM2级方法，则使用该方法，传入三个参数；如果存在的是IE的方法，则采取第二种方案。如果前面两者都不存在的话，那就是采取最后一张方案，使用DOM0级方法。<br>对EventUtil对象进行使用：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(btn, <span class="string">&quot;click&quot;</span>, handler); </span><br><span class="line">EventUtil.removeHandler(btn, <span class="string">&quot;click&quot;</span>, handler); </span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之数组</title>
    <url>/2016/08/14/JS%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>创建数组的方式有2种，如下：</p>
<h4 id="使用Array构造函数"><a href="#使用Array构造函数" class="headerlink" title="使用Array构造函数"></a>使用Array构造函数</h4><ol>
<li>不传入参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> students= <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//创建一个空数组</span></span><br></pre></td></tr></table></figure></li>
<li>传入一个数值作为参数，指定数组的长度<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> students= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); <span class="comment">//创建一个length值为10的数组</span></span><br></pre></td></tr></table></figure></li>
<li>传入一个或者多个数组元素作为参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> students= <span class="keyword">new</span> <span class="built_in">Array</span>(“red”,”blue”); <span class="comment">//创建包含2个字符串值的数组</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="使用数组字面量表示法"><a href="#使用数组字面量表示法" class="headerlink" title="使用数组字面量表示法"></a>使用数组字面量表示法</h4><p>数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [];<span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>];<span class="comment">//创建包含2个字符串值的数组</span></span><br></pre></td></tr></table></figure>

<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>对于一个网页或者一个全局作用域而言，使用<strong>instanceof操作符</strong>即可确定某个对象是不是数组。但是在当存在多个全局作用域(如一个页面包含多个frame)的情况下，使用instanceof操作符就会出现各种问题。因此可以使用**Array.isArray()**方法，该方法的目的是最终确定某个值是不是数组，而不管它是在哪个全局执行环境中创建的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;  <span class="comment">//instanceof操作符</span></span><br><span class="line"><span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;  <span class="comment">//Array.isArray()方法</span></span><br><span class="line"><span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><ul>
<li><strong>toLocaleString()：</strong>返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li><strong>toString()：</strong>返回对象的字符串表示。</li>
<li><strong>valueOf()：</strong>返回对象的字符串、数组或布尔值。通常与toString()方法的返回值相同。</li>
<li><strong>join()：</strong>返回对象用符号连接的的字符串表示。join()方法只接收一个参数，即作为分隔符的字符串，如果没有传入参数，则默认以逗号作为分隔符。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">//创建一个包含3个字符串的数组  </span></span><br><span class="line">alert(colors.toString());    <span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors.valueOf());    <span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors.toLocaleString());    <span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors.join(<span class="string">&#x27;||&#x27;</span>));    <span class="comment">//red||blue||green</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>栈是一种后进先出的数据结构，最新添加的项最早被移除。栈中项的插入和移除都只发生在一个位置——栈的顶部。数组可以表现的像栈一样，通过push()方法和pop()方法实现类似栈的行为。</p>
<ul>
<li><strong>push()：</strong>可以接收任何数量的参数，把它们逐个添加到数组的末尾，并<strong>返回数组的长度</strong>。</li>
<li><strong>pop()：</strong>从数组末尾移除最后一项，减少数组的length值，然后<strong>返回移除的项</strong>。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);  <span class="comment">//推入两项</span></span><br><span class="line">alert(count);  <span class="comment">//2  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop();         <span class="comment">//取得最后一项</span></span><br><span class="line">alert(item);   <span class="comment">//&quot;green&quot;</span></span><br><span class="line">alert(colors.length);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2>队列是一种先进先出的数据结构，队列在列表的末端添加项，从列表的前端移除项。数组可以表现的像队列一样，通过push()方法和shift()方法实现类似队列的行为。</li>
<li><strong>push()：</strong>向数组末端添加项。</li>
<li><strong>shift()：</strong>移除数组中的第一个想并返回该项，同时将数组长度减1。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();     <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>,<span class="string">&quot;black&quot;</span>);   <span class="comment">//从末端推入三项</span></span><br><span class="line">alert(count);  <span class="comment">//3</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> item = colors.shift();    <span class="comment">//取得第一项</span></span><br><span class="line">alert(item);   <span class="comment">//&quot;red&quot;</span></span><br><span class="line">alert(colors.length);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
数组还有一个<strong>unshift()方法</strong>，与shift()方法的用途恰恰相反，在数组的前端添加任意个项并返回新数组的长度，同时使用unshift()方法和pop()方法，可以实现模拟队列的效果，即在数组的前端添加项，从数组的末端移除项。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();   <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.unshift(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>,<span class="string">&quot;black&quot;</span>);    <span class="comment">//从前端推入三项</span></span><br><span class="line">alert(count);  <span class="comment">//3</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">var</span> item = colors.pop();   <span class="comment">//取得最后一项</span></span><br><span class="line">alert(item);   <span class="comment">//&quot;black&quot;</span></span><br><span class="line">alert(colors.length);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2>数组中有两种可以直接用来重排序的方法：reverse()和sort()。</li>
<li><strong>reverse()：</strong>反转数组项的顺序。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values);       <span class="comment">//5,4,3,2,1</span></span><br></pre></td></tr></table></figure></li>
<li><strong>sort()：</strong>对数组进行排序。sort()方法比较的是字符串，即使数组中的每一项都是数值，可以看下面的例子：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values);    <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
上面的例子中，虽然数值5小于10，但在进行字符串比较时，“10”则位于“5”前面，所以并非像我们所想象的那样，按数值的大小进行排序。<br>因此sort()方法可以接收一个比较函数compare(a,b)作为参数，这个比较函数接收两个参数a和b，a,b表示数组中的任意两个元素。如果a应该位于b之前，则返回一个负数；如果a等于b，则返回0；如果a应该位于b之后，则返回一个正数。这里产生的是升序排列的结果。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a&lt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);    <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
如果想产生降序排列的结果，只需交换比较函数的返回值即可。</li>
</ul>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul>
<li><strong>concat()：</strong>基于当前数组中所有项创建一个新数组。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。<br>(1) 没有参数：只是复制当前数组并返回副本。<br>(2)有参数：传递值或者数组，则将这些值或者或者数组中每一项都添加到结果数组的末尾。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line">alert(colors);     <span class="comment">//red,green,blue        </span></span><br><span class="line">alert(colors2);    <span class="comment">//red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure></li>
<li><strong>slice()：</strong>基于当前数组中的一或多个项创建一个新数组。该方法接收一或<br>两个参数，即要返回项的起始和结束位置。<br>(1) 一个参数：返回从参数指定位置开始到当前数组末尾的所有项。<br>(2) 两个参数：返回起始和结束位置之间的项，但不包括结束位置的项。<br>(3) 参数为负数：使用数组长度加上该数来确定相应的位置。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);<span class="comment">//不包括结束位置的项</span></span><br><span class="line"><span class="keyword">var</span> colors4 = colors.slice(-<span class="number">2</span>,-<span class="number">1</span>);<span class="comment">//与slice(3,-4)结果相同</span></span><br><span class="line"></span><br><span class="line">alert(colors2);   <span class="comment">//green,blue,yellow,purple</span></span><br><span class="line">alert(colors3);   <span class="comment">//green,blue,yellow</span></span><br><span class="line">alert(colors4);  <span class="comment">//yellow</span></span><br></pre></td></tr></table></figure></li>
<li><strong>splice()：</strong>向数组的中部插入项。可以实现三种效果：<br>(1) <strong>删除：</strong>可以删除任意数量的项。指定2个参数：要删除的第一项的位置和要删除的项数。例如：splice(0,1)会删除数组中的第一项。<br>(2) <strong>插入：</strong>可以向指定位置插入任意数量的项。指定3个参数：起始位置、<br>0（要删除的项数）和要插入的项。例如：splice(1,0,3)会从位置1插入数字3。<br>(3) <strong>替换：</strong>可以向指定位置插入任意数量的项，且同时删除任意数量的项，指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的数量不必与删除的数量相等。例如，splice(1,1,3,2)会删除当前数组位置1的项，容纳后再从位置1开始插入数字3和2。</li>
</ul>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p><strong>indexOf()和lastIndexOf()方法</strong>是数组的两个位置方法，这两个方法接收两个参数：要查找的项和表示查找起点位置的索引(可选的)，都是返回要查找的项在数组中的位置，如果没找到，则返回-1.<br>两个方法主要的区别：indexOf()方法从数组的<strong>开头</strong>(位置为0)开始向后查找，而lastIndexOf()方法则是从数组的<strong>末尾</strong>开始向前查找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>];   </span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>));        <span class="comment">//3</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>));    <span class="comment">//5</span></span><br><span class="line">        </span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>, <span class="number">3</span>));     <span class="comment">//3</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">5</span>)); <span class="comment">//5</span></span><br><span class="line">alert(numbers.indexOf(<span class="number">6</span>));  <span class="comment">//-1  </span></span><br></pre></td></tr></table></figure>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>数组具有5个迭代方法，每个方法都接收2个参数：①要在每一项运行的函数；②(可选的)运行在该函数的作用域对象——影响this的值。对于参数一传入的函数会接收3个参数：数组项的值、该项在数组中的位置和数组对象本身。</p>
<ul>
<li><strong>every()和some()方法：</strong>用于查询数组中的项是否满足某个条件，返回true或false。二者的区别在于，every()方法，传入的函数必须对<strong>每一项</strong>都返回true，这个方法才返回true；而some()方法则只有传入的函数对数组的<strong>某一项</strong>返回true，就会返回true。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>];   </span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">alert(everyResult);       <span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">alert(someResult);       <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><strong>filter()：</strong>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。这个方法对查询某些符合条件的所有数组项非常有用。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">alert(filterResult);   <span class="comment">//返回所有数值大于2的数组：[3,4,5,4]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>map()：</strong>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。这个方法适合创建包含的项与另一个数组一一对应的数组。下面例子返回数组中每一项乘于2所得乘积组成的数组。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];    </span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">alert(mapResult);   <span class="comment">//[2,4,6,8,10]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><strong>forEach()：</strong>对数组中的每一项运行给定函数，没有返回值。本质上与使用for迭代数组一样。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];  </span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arry</span>)</span>&#123;  <span class="comment">//对数组的每个元素累加</span></span><br><span class="line">  arry[index] = item+<span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(numbers);  <span class="comment">//[ 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p><strong>reduce()和reduceRight()方法</strong>： 都会迭代数组的所有项，然后构建一个最终返回的值。两个方法都接收2个参数：①一个在每一项调用的函数；②作为归并基础的初始值（可选的），这个参数如果没有指定，那么将使用数组的第一个元素作为初始值。对于传入到两种方法的函数也接收4个参数：前一个值、当前值、项的索引和数组对象。<br>那么两种方法区别在哪呢？跟indexOf()和lastIndexOf()方法很相似，二者的区别在于，reduce()方法从数组的<strong>第一项</strong>开始，逐个遍历到最后；而reduceRight()方法则从数组的<strong>最后一项</strong>开始，向前遍历到第一项。下面例子为对数组中所有值进行求和的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum1 = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line">alert(sum1);<span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum2 = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line">alert(sum2);<span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<p>可以看到，除了遍历数组的方向相反外，reduce()和reduceRight()方法完全相同。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之绑定事件</title>
    <url>/2016/08/01/JS%E4%B9%8B%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>当我们给一个元素绑定一个方法后，再绑定一个方法时，第一个方法往往会被覆盖掉。如下例子，结果只会执行第二个方法，也就是说只弹出“b”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此为了保证两个及以上的方法能够正常执行，可以对元素进行事件绑定。<br>绑定事件有两个函数，attachEvent()和addEventListener()。</p>
<ol>
<li>attachEvent(事件名称, 函数)，IE浏览器兼容，这个函数的执行顺序是相反的，即先绑定的方法后面执行。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oBtn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>,bb);</span><br><span class="line">oBtn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>,aa);<span class="comment">//先执行方法aa,再执行方法bb</span></span><br></pre></td></tr></table></figure></li>
<li>addEventListener(事件名称,函数, 捕获)，ff和chrome浏览器兼容，这个函数的执行顺序是按正常的顺序执行的，即先绑定的方法先执行。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>,aa,<span class="literal">false</span>);</span><br><span class="line">oBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>,bb,<span class="literal">false</span>);<span class="comment">//先执行方法aa,再执行方法bb</span></span><br></pre></td></tr></table></figure>
为了解决浏览器兼容性问题，使用if-else语句来处理兼容性，使其兼容所有的浏览器。这里要注意一点，attachEvent()的事件名称要比addEventListener()的事件名称前面多了个‘on’。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span>(oBtn.attachEvent)<span class="comment">//IE</span></span><br><span class="line"> &#123;</span><br><span class="line">     oBtn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>,bb);</span><br><span class="line">     oBtn.attachEvent(<span class="string">&#x27;onclick&#x27;</span>,aa);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//ff、chrome</span></span><br><span class="line"> &#123;</span><br><span class="line">     oBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>,aa,<span class="literal">false</span>);</span><br><span class="line">     oBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>,bb,<span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
到此一个事件绑定就完成了，但是为了使代码更加简洁明了，且方便调用，可以将此解决兼容性的if-else语句封装成一个函数。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAddEvent</span>(<span class="params">obj,sEvent,fn</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.attachEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                obj.attachEvent(<span class="string">&#x27;on&#x27;</span>+sEvent,fn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                obj.addEventListener(sEvent,fn,<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
之后就可以根据需要调用该封装函数了。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myAddEvent(oBtn,<span class="string">&#x27;click&#x27;</span>,aa)</span><br><span class="line">myAddEvent(oBtn,<span class="string">&#x27;click&#x27;</span>,bb);</span><br></pre></td></tr></table></figure>
既然可以对元素进行事件绑定，当然也可以解除绑定。解除绑定同样有两个函数detachEvent(事件名称, 函数)和removeEventListener(事件名称, 函数, 捕获)，分别对应attachEvent()和addEventListener()的解绑。由于二者的用法同attachEvent()和addEventListener()的用法类似，所以这里就不再进行详细的说明了。</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之运动1</title>
    <url>/2016/07/19/JS%E4%B9%8B%E8%BF%90%E5%8A%A81/</url>
    <content><![CDATA[<p>今天学习了 JS 的运动，从最简单的一个 div 运动到多个 div 运动开始，到后面通过 div 的运动实现常见的侧边栏的隐藏与显示，最后还实现图片或者 div 块的淡入淡出。最终总结起来其实都是一个运动函数 startMove()的套用，涉及定时器的关与开。仔细观察下每个例子的 startMove()运动函数，会发现都是大同小异的，所以将 startMove()运动函数封装起来，当需要的时候导入，再修改下相应的参数即可，这样可以大大实现代码的简洁性。下面就是封装该函数的一个过程。</p>
<p>首先，获取样式表指定对象的属性值，其中涉及浏览器兼容性问题，利用 if-else 语句来解决兼容性问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj, attr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (obj.currentStyle) &#123;</span><br><span class="line">		<span class="keyword">return</span> obj.currentStyle[attr]; <span class="comment">//只支持IE浏览器</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getComputedStyle(obj, <span class="literal">false</span>)[attr]; <span class="comment">//支持火狐，谷歌等浏览器，IE浏览器不支持</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，就是设置 startMove()函数里面包含的真正内容了，</p>
<ol>
<li>设置三个参数值，分别为 obj（对象），attr（属性值），iTarget（目标值）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startMove</span>(<span class="params">obj, attr, iTarget</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置定时器。开启一个定时器前应该先关闭定时器，因为如果没有先关闭定时器，那么当重复点击运动按钮时，会重复执行 startMove()运动函数，即一起开启多个定时器，导致运动的重复和混乱。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">        obj.timer=<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;  ... &#125;,<span class="number">30</span>);      &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置定时器内部的内容。这里要注意一点，如果设置的是透明度的值，因为有可能会是小数点，所以需要用 parseFloat；反之，如果设置的是非透明度值，则用 parseInt。（iCur 的初值为 0，为所指定属性的值）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (attr == <span class="string">&quot;opacity&quot;</span>) &#123;</span><br><span class="line">	<span class="comment">//iCur=parseFloat(getStyle(obj,attr))*100;//结果是小数，会出现闪烁</span></span><br><span class="line">	iCur = <span class="built_in">parseInt</span>(<span class="built_in">parseFloat</span>(getStyle(obj, attr)) * <span class="number">100</span>); <span class="comment">//将小数部分去掉，解决闪烁</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//传进来的参数不是透明度，采用parseInt方法</span></span><br><span class="line">	iCur = <span class="built_in">parseInt</span>(getStyle(obj, attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置运动速度，这里设置速度值 iSpeed 为目标值与当前属性值的差再除以 8，当速度值大于 0 时，将其向上取整，否则向下取整。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iSpeed = (json[attr] - iCur) / <span class="number">8</span>;</span><br><span class="line">iSpeed = iSpeed &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(iSpeed) : <span class="built_in">Math</span>.floor(iSpeed);</span><br></pre></td></tr></table></figure>

<p>最后就是将指定属性的当前值与目标值做判断，等于目标值时关闭定时器，否则将属性的当前值加上速度值形成最新的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (iCur == iTarget) &#123;</span><br><span class="line">	<span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (attr == <span class="string">&quot;opacity&quot;</span>) &#123;</span><br><span class="line">		obj.style.filter = <span class="string">&quot;alpha(opacity:&quot;</span> + (iCur + iSpeed) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">		obj.style.opacity = (iCur + iSpeed) / <span class="number">100</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		obj.style[attr] = iCur + iSpeed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此一个运动函数搞定了，当需要导入到 html 文档时，只要添加如下命令，再修改下参数即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;move2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下面例子中，改变 oDiv1 中的 opacity 属性，使其达到 100。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startMove(oDiv1,&#39;opacity&#39;,100);</span><br></pre></td></tr></table></figure>

<p>总结下，今天主要收获是学习并一定程度掌握了 JS 的运动框架。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>运动框架</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之运动2</title>
    <url>/2016/07/20/JS%E4%B9%8B%E8%BF%90%E5%8A%A82/</url>
    <content><![CDATA[<p>今天继续了 JS 运动的学习，本来以为昨天总结的运动函数 startMove()是最完整的了，才发现昨天那个还是存在欠缺部分，只能实现单个 div 单个运动。今天将这个运动函数进行改进，实现了多个 div 运动以及同一个 div 的多值运动。改进版运动函数跟之前的差别不大，首先是参数的改变，由原来的 2 个变成 3 个，参数类型也变了,”function startMove(obj,json,fn)”。其次是多了个布尔变量 bStop，该变量用来判断运动是否结束；最后是添加一个 if 语句，判断是否传入 fn 参数，以此来决定执行不执行 fn,”if(fn){fn();}”。</p>
<p>然后学到的就是图片轮换播放，这是今天最大的收获了。下面就是实现图片轮换播放的过程。</p>
<ol>
<li>用 class 名称选取元素，需要注意，js 中的 class 是关键字，所以必须写成 className。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getByClass</span>(<span class="params">oParent, sClass</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> aEle = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;*&quot;</span>); <span class="comment">//选出父节点下的所有元素</span></span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">var</span> aResult = []; <span class="comment">//定义一个空的数组，用来装所有的选出元素</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; aEle.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (aEle[i].className == sClass) &#123;</span><br><span class="line">			aResult.push(aEle[i]); <span class="comment">//将选出的所有元素装入数组中</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> aResult; <span class="comment">//  循环完成后，返回数组里的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>点击实现上下张图片的左右按钮，通过改变其透明度的大小，实现鼠标移入移出渐隐渐现功能。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oBtnPrev.onmouseover = oMarkLeft.onmouseover = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	startMove(oBtnPrev, <span class="string">&quot;opacity&quot;</span>, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line">oBtnPrev.onmouseout = oMarkLeft.onmouseout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	startMove(oBtnPrev, <span class="string">&quot;opacity&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">oBtnNext.onmouseover = oMarkRight.onmouseover = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	startMove(oBtnNext, <span class="string">&quot;opacity&quot;</span>, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line">oBtnNext.onmouseout = oMarkRight.onmouseout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	startMove(oBtnNext, <span class="string">&quot;opacity&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现小图移入渐隐渐现效果，配合点击时的变化功能，当重复点击同一张图片时，不做任何处理。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aSmallLi[i].onmouseover = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	startMove(<span class="built_in">this</span>, <span class="string">&quot;opacity&quot;</span>, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line">aSmallLi[i].onmouseout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.index != iNow) &#123;</span><br><span class="line">		<span class="comment">//在非当前图片移入移出</span></span><br><span class="line">		startMove(<span class="built_in">this</span>, <span class="string">&quot;opacity&quot;</span>, <span class="number">60</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">aSmallLi[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.index == iNow) <span class="keyword">return</span>; <span class="comment">//重复点击同一张图片，不做处理</span></span><br><span class="line">	iNow = <span class="built_in">this</span>.index; <span class="comment">//更新</span></span><br><span class="line">	tab();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当点击小图时，对应大图进行切换。这里要注意的是需要给每张图片加层级，点击即将要显示的图片必须让它的 Zindex 值比当前显示的图片大，这样才能覆盖当前图片显示。还有利用运动函数让大图的高度由 0 开始增大，实现大图下拉显示的效果。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; aSmallLi.length; i++) &#123;</span><br><span class="line">	startMove(aSmallLi[i], <span class="string">&quot;opacity&quot;</span>, <span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line">startMove(aSmallLi[iNow], <span class="string">&quot;opacity&quot;</span>, <span class="number">100</span>);</span><br><span class="line">aBigLi[iNow].style.zIndex = iMinZindex++; <span class="comment">//加层级，否则只会显示第一张图片，其他都会被挡住</span></span><br><span class="line">aBigLi[iNow].style.height = <span class="number">0</span>; <span class="comment">//使图片从上往下显示</span></span><br><span class="line">startMove(aBigLi[iNow], <span class="string">&quot;height&quot;</span>, oBigUl.offsetHeight);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>随着点击下一张图片时，发生居中切换的效果。首尾图片的位置需要做特殊处理，避免出现前后的空白。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (iNow == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//第0张，移动到0，否则会前面有空白</span></span><br><span class="line">	startMove(oSmallUl, <span class="string">&quot;left&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (iNow == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//第二张</span></span><br><span class="line">	startMove(oSmallUl, <span class="string">&quot;left&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (iNow == aSmallLi.length - <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//最后一张</span></span><br><span class="line">	startMove(oSmallUl, <span class="string">&quot;left&quot;</span>, -(iNow - <span class="number">3</span>) * aSmallLi[<span class="number">0</span>].offsetWidth);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	startMove(oSmallUl, <span class="string">&quot;left&quot;</span>, -(iNow - <span class="number">2</span>) * aSmallLi[<span class="number">0</span>].offsetWidth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>给左右按钮添加点击动作，点击第一张图片时，跳到最后一张，点击最后一张时，跳到第一张。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oBtnPrev.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	iNow--;</span><br><span class="line">	<span class="keyword">if</span> (iNow == -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//到0张，直接到最后一张</span></span><br><span class="line">		iNow = aSmallLi.length - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	tab();</span><br><span class="line">&#125;;</span><br><span class="line">oBtnNext.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	iNow++;</span><br><span class="line">	<span class="keyword">if</span> (iNow == aSmallLi.length) &#123;</span><br><span class="line">		<span class="comment">//到最后一张，直接到第0张</span></span><br><span class="line">		iNow = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	tab();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>执行完以上六个步骤，得到如下效果图:<br><img src="/images/content/1.png" alt="效果图1"><br>以上代码为参考课程所给案例进行编写测试的，对其进行修改，将底下小图片显示的个数增加到四张，首先是通过样式改变小图的宽度，此时第一张及最后一张都会出现空白，所以还需要对图片的位置进行上述步骤五的处理，如下，这样一个图片轮播的效果就出来了。<br><img src="/images/content/2.png" alt="效果图2"><br>运动函数以及图片轮播经常在一些网站上出现，所以个人感觉学会它们是很有必要的，目前学到也只是初步的一些东西，后面还是需要进行一些深入学习与练习才能真正掌握它们。</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>图片轮播</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之闭包</title>
    <url>/2016/08/10/JS%E4%B9%8B%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是指有权访问另外一个函数作用域中的变量的函数。<br>简单的说，在Javascript中，函数内部作用域可以访问外部作用域的变量，而外部作用域却无权访问内部作用域的局部变量。但是有时候我们需要在函数作用域外访问到函数内部的变量，这个时候就需要闭包的出场了。通过在函数的内部在创建一个函数，将内部函数作为返回值，就可以在函数外去访问到函数的内部变量。</p>
<h2 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h2><p>先看下面的一段关于闭包的代码，通过这段代码来逐一分析闭包的特点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(a);</span><br><span class="line">        alert(b);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>函数嵌套函数</strong>：<br>aaa()函数里再嵌套了一个bbb()函数。</li>
<li><strong>内部函数可以引用外部函数的参数和变量</strong>：<br> bbb()函数里可以引用aaa()函数中的a参数和b变量。</li>
<li><strong>参数和变量不会被垃圾回收机制所收回</strong>：<br> a和b的值不会被垃圾回收机制回收，因为它们都要在内部函数bbb()中被引用。</li>
</ol>
<h2 id="使用闭包的好处"><a href="#使用闭包的好处" class="headerlink" title="使用闭包的好处"></a>使用闭包的好处</h2><ol>
<li><strong>希望一个变量长期驻扎在内存当中（不会被垃圾回收机制回收）。</strong></li>
<li><strong>避免全局变量的污染(为了提高性能，尽量避免出现全局变量)。</strong><br> (1) 全局变量的累加：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> a=<span class="number">1</span>;<span class="comment">//全局变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;</span><br><span class="line">    aaa();<span class="comment">//2</span></span><br><span class="line">    aaa();<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
 (2) 将全局变量a变成局部变量(但是不能累加)：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">    a++;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;</span><br><span class="line">    aaa();<span class="comment">//2</span></span><br><span class="line">    aaa();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
 (3) 不仅将全局变量a变成局部变量，还可以实现累加(采用闭包)：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    alert(a);&#125;&#125;</span><br><span class="line">    <span class="keyword">var</span> b=aaa();</span><br><span class="line">    b();<span class="comment">//2</span></span><br><span class="line">    b();<span class="comment">//3</span></span><br></pre></td></tr></table></figure></li>
<li><strong>私有成员的存在</strong></li>
</ol>
<h2 id="使用闭包的注意事项"><a href="#使用闭包的注意事项" class="headerlink" title="使用闭包的注意事项"></a>使用闭包的注意事项</h2><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>由于闭包会携带私有成员的存在包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。<br>解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<h3 id="闭包和变量"><a href="#闭包和变量" class="headerlink" title="闭包和变量"></a>闭包和变量</h3><p>闭包只能取得包含函数中的任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result=[];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i= <span class="number">0</span>;i&lt;<span class="number">3</span>;i=i+<span class="number">1</span>)&#123;</span><br><span class="line">        result[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(i)</span><br><span class="line">        &#125;   &#125;   &#125;;</span><br><span class="line">aa();</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 3</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这段代码中,表面上看，aa函数中的变量i被内部循环的函数使用,并且能分别获得他们的索引值,而实际上,只能获得该变量最后保留的值。因为闭包中所记录的自由变量,只是对这个变量的一个引用,而非变量的值,当这个变量被改变了,闭包里获取到的变量值,也会被改变。<br>解决的方法：是让内部函数在循环创建的时候立即执行,并且捕捉当前的索引值,然后记录在自己的一个本地变量里.再利用返回函数的方法,重写内部函数,让下一次调用的时候,返回本地变量的值,改进后的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result=[];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i= <span class="number">0</span>;i&lt;<span class="number">3</span>;i=i+<span class="number">1</span>)&#123;</span><br><span class="line">        result[i]=(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(j);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;   &#125;;</span><br><span class="line">aa();</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h3><p>我们都知道，this对象是在运行时基于函数的执行环境绑定的，在全局函数中，this等于window。而当函数被作为某个对象的方法调用时，this等于那个对象。不过，在匿名函数中，其执行环境具有全局性，因此其this对象通常指的是window。下面看下一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = “The <span class="built_in">window</span>”;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: “My <span class="built_in">Object</span>”,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;  &#125;      &#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">//The window</span></span><br></pre></td></tr></table></figure>
<p>以上代码先创建了一个全局变量name，又创建了一个包含name属性的对象，这个对象还包含一个getNameFunc()方法，它返回一个匿名函数，而匿名函数又返回this.name。因此调用object.getNameFunc()()会立即调用它返回的函数，结果就是返回一个字符串，这个字符中就是全局name的值，即“The window”。如果想访问匿名函数外部作用域的this对象，可以做如下的改进：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = “The <span class="built_in">window</span>”;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: “My <span class="built_in">Object</span>”,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that= <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;    &#125;  &#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">//My Object</span></span><br></pre></td></tr></table></figure>
<p>上述改进后的代码，在定义匿名函数之前，把this对象赋值给了一个名叫that的变量，而定义了闭包之后，闭包也可以访问这个变量，因为他是在包含函数中特意声明的一个变量，即使在函数返回后，that依旧引用着object，所以调用object.getNameFunc()()就返回了“My Object”。</p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><h3 id="匿名自执行函数"><a href="#匿名自执行函数" class="headerlink" title="匿名自执行函数"></a>匿名自执行函数</h3><p>函数内部声明变量的时候，如果不加上var关键字，就会默认声明一个全局变量，这样的临时变量加入全局对象有很多坏处，可能造成全局对象过于庞大，影响访问速度等等。除了每次使用变量都是用var关键字外，也遇到这样一种情况，就是有的函数只需要执行一次，其内部变量无需维护，这个时候就可以使用闭包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data= &#123;    </span><br><span class="line">    table : [],    </span><br><span class="line">    tree : &#123;&#125;    </span><br><span class="line">&#125;;      </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">dm</span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dm.table.rows; i++)&#123;    </span><br><span class="line">       <span class="keyword">var</span> row = dm.table.rows[i];    </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; row.cells; i++)&#123;    </span><br><span class="line">           drawCell(i, j);    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;         </span><br><span class="line">&#125;)(data); </span><br></pre></td></tr></table></figure>
<p>我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，这种机制不会污染全局对象。</p>
<h3 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h3><p>在开发过程中，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CachedSearchBox = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;,    </span><br><span class="line">       count = [];    </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       attachSearchBox : <span class="function"><span class="keyword">function</span>(<span class="params">dsid</span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;<span class="comment">//如果结果在缓存中    </span></span><br><span class="line">              <span class="keyword">return</span> cache[dsid];<span class="comment">//直接返回缓存中的对象    </span></span><br><span class="line">           &#125;    </span><br><span class="line">           <span class="keyword">var</span> fsb = <span class="keyword">new</span> uikit.webctrl.SearchBox(dsid);<span class="comment">//新建    </span></span><br><span class="line">           cache[dsid] = fsb;<span class="comment">//更新缓存    </span></span><br><span class="line">           <span class="keyword">if</span>(count.length &gt; <span class="number">100</span>)&#123;<span class="comment">//保正缓存的大小&lt;=100    </span></span><br><span class="line">              <span class="keyword">delete</span> cache[count.shift()];    </span><br><span class="line">           &#125;    </span><br><span class="line">           <span class="keyword">return</span> fsb;          </span><br><span class="line">       &#125;,    </span><br><span class="line">       clearSearchBox : <span class="function"><span class="keyword">function</span>(<span class="params">dsid</span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;    </span><br><span class="line">              cache[dsid].clearSelection();      </span><br><span class="line">           &#125;     &#125;     &#125;;    </span><br><span class="line">&#125;)();      </span><br><span class="line">CachedSearchBox.attachSearchBox(<span class="string">&quot;input1&quot;</span>); </span><br></pre></td></tr></table></figure>
<p>当我们第二次调用CachedSearchBox.attachSerachBox(“input1”)的时候，我们就可以从缓存中读取到该对象，而不用再去创建一个新的searchbox对象。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>来看下面的一个例子，在person之外的地方无法访问其内部的变量，但是可以通过提供闭包的形式来访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="comment">//变量作用域为函数内部，外部无法访问    </span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;default&quot;</span>;       </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">return</span> name;    </span><br><span class="line">       &#125;,    </span><br><span class="line">       setName : <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;    </span><br><span class="line">           name = newName;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;();    </span><br><span class="line">print(person.name);<span class="comment">//直接访问，结果为undefined    </span></span><br><span class="line">print(person.getName());    <span class="comment">//default  </span></span><br><span class="line">person.setName(<span class="string">&quot;abruzzi&quot;</span>);    </span><br><span class="line">print(person.getName());  <span class="comment">//abruzzi </span></span><br></pre></td></tr></table></figure>
<h3 id="实现类和继承"><a href="#实现类和继承" class="headerlink" title="实现类和继承"></a>实现类和继承</h3><p>闭包的一个重要用途是实现面向对象中的对象，传统的对象语言都提供类的模板机制，这样不同的对象(类的实例)拥有独立的成员及状态，互不干涉。虽然JavaScript中没有类这样的机制，但是通过使用闭包，我们可以模拟出这样的机制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;default&quot;</span>;       </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">return</span> name;    </span><br><span class="line">       &#125;,    </span><br><span class="line">       setName : <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;    </span><br><span class="line">           name = newName;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;    </span><br><span class="line">     </span><br><span class="line"><span class="keyword">var</span> john = Person();    </span><br><span class="line">print(john.getName());    <span class="comment">//default</span></span><br><span class="line">john.setName(<span class="string">&quot;john&quot;</span>);    </span><br><span class="line">print(john.getName());    <span class="comment">//john</span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">var</span> jack = Person();    </span><br><span class="line">print(jack.getName());    <span class="comment">//default</span></span><br><span class="line">jack.setName(<span class="string">&quot;jack&quot;</span>);    </span><br><span class="line">print(jack.getName());    <span class="comment">//jack</span></span><br></pre></td></tr></table></figure>
<p>上述的代码，定义了Person，它就像一个类，可以通过new一个Person对象，来访问它的方法。john和jack都可以称为是Person这个类的实例，它们继承了Person，并添加自己的方法，并且这两个实例对name这个成员的访问是独立的，互不影响的。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之面向对象1</title>
    <url>/2016/07/21/JS%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/</url>
    <content><![CDATA[<p>今天学习了JS的面向对象部分内容。首先是理解面向对象的概念，因为之前在学校学的几门编程语言都有接触面向对象这个概念，所以理解起来相对来说还是比较容易的。面向对象只关注对象提供的功能，不关注其内部细节，就像我们使用收音机时不需要知道收音机里面的构造以及连线方式，而只需要知道收音机各个按钮的功能即可，收音机就是一个对象。面向对象具有三个特性：封装，继承，多态，并且由方法和属性组成。这些大都已经记在心中了，考过好几次了。</p>
<p>接着就是学会用工厂方式构造对象，分为三步：</p>
<ol>
<li>工厂制作产品首先需要的是原料，对应的我们需要创建一个空白的对象；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li>
<li>对原料进行加工，即对应的我们需要为对象添加属性和方法；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.name=name;</span><br><span class="line">obj.sex=sex;</span><br><span class="line">obj.showName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;我的名字叫&#x27;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">obj.showSex=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;我是&#x27;</span>+<span class="built_in">this</span>.sex+<span class="string">&#x27;的&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将加工好的产品送出厂，所以我们需要返回对象。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>虽然工厂方式看起来挺完美的，但是还是存在两个问题：其一，没有new；其二，函数重复定义，即每个对象都有一套自己的函数，浪费资源。问题一解决相对来说比较简单，添加一个new即可，主要还是问题二的解决。问题二可以用原型prototype为对象添加方法，原型prototype又是今天新学到的一个概念，通过原型添加方法可以在已有对象中加入自己的方法，可以扩展系统对象，添加一些本不支持的方法。用原型添加方法不仅给构造函数于极度的简化，而且使所有同类的对象都只有一套方法，节省了大量的资源，有效地解决了工厂方法的第二个问题。所以对上述的工厂方法进行改进，首先是将原来的构造函数删除部分，再将剩下的关于属性的部分稍微修改成如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,sex</span>)//构造函数，添加属性</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name=name;</span><br><span class="line">            <span class="built_in">this</span>.sex=sex;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>接着就是解决问题一了，加new，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Person(<span class="string">&#x27;Rose&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>然后就是解决问题二了，用原型为对象添加方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.showName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)//原型，添加方法</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        Person.prototype.showSex=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.sex);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>最后，调用方法即可，这样子一来，一套相对比较完美的构造对象方法就出炉了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.showName();</span><br><span class="line">p.showSex();</span><br></pre></td></tr></table></figure>
<p>以上就是今天主要学到的三方面的内容：面向对象概念，工厂方法构造对象，原型添加方法。原型为对象添加方法真的很好用，今天学到的可能只是一小部分，更多的需要后期接触再去深入学习了。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>工厂方式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript的异常处理和事件处理</title>
    <url>/2016/07/29/Javascript%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="Javascript的异常处理"><a href="#Javascript的异常处理" class="headerlink" title="Javascript的异常处理"></a>Javascript的异常处理</h4><p>Javascript的异常就是当javascript引擎执行javascript代码时，发生了错误，导致程序停止运行的一种现象。当异常产生时，会创建一个异常类对象，该异常类对象将被提交给浏览器，这个过程称为“抛出异常”。当浏览器接收到异常对象时，会寻找能处理这一异常的代码并把当前异常对象提交给其处理，这一过程被称为“捕获异常”。<br>Javascript使用try..catch..finally语句来进行异常的捕获，try..catch..finally语句的基本语法格式为： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的代码 </span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">     <span class="comment">//如果发生异常会执行的代码，error为发生的异常类对象 </span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无条件执行的代码 </span></span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>try块中的语句首先被执行。如果运行中发生了错误，控制就会转移到位于catch块中语句，其中括号中的error参数被作为例外变量传递。否则，catch块的语句被跳过不执行。无论是发生错误时catch块中的语句执行完毕，或者没有发生错误try块中的语句执行完毕，最后将执行 finally块中的语句。在try..catch..finally语句中，try是必需的，catch和finally均为可选语句，但catch和finally中必须至少出现一个。<br>下面例子为捕获到的是变量未定义的异常：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;   <span class="keyword">var</span> str=<span class="string">&quot;你好&quot;</span>; <span class="comment">//没有声明str的话会有异常</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                alert(str);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(er)&#123;</span><br><span class="line">                alert(er);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        demo();</span><br></pre></td></tr></table></figure>
<p>Javascript抛出异常使用的是throw语句，可创建一个自定义异常。将throw语句于try..catch..finally语句结合使用，能够控制程序流，并生成自定义的错误消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;   </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> e=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>).value;</span><br><span class="line">                <span class="keyword">if</span>(e==<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="string">&quot;第一个用户输入异常==空&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(er)&#123;</span><br><span class="line">                alert(er);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        demo();</span><br></pre></td></tr></table></figure>

<h4 id="Javascript的事件处理"><a href="#Javascript的事件处理" class="headerlink" title="Javascript的事件处理"></a>Javascript的事件处理</h4><p>事件指的是文档或者浏览器窗口中发生的一些特定交互瞬间。与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个load事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。这里列举了Javascript几个常用的事件：    </p>
<ul>
<li>onClick：鼠标点击触发的事件，多用在某个对象控制的范围内的鼠标点击</li>
<li>onMouseOver：鼠标移入元素时触发的事件。</li>
<li>onMouseOut：鼠标移开元素时触发的事件。</li>
<li>onChnange：当文本内容改变时触发的事件。</li>
<li>onSelect：当文本框被选中时触发的事件。</li>
<li>onFocus：光标聚集事件，即在对象获得焦点时触发的事件。</li>
<li>onBlur：移开光标事件，即在对象失去焦点时触发的事件。</li>
<li>onLoad：网页加载事件，即在网页加载完成触发的事件。</li>
<li>onUnload：关闭网页事件，即退出网页时触发的事件</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之面向对象2</title>
    <url>/2016/07/23/JS%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/</url>
    <content><![CDATA[<p>今天学习了JS面向对象的一个特性–继承。JS是一门基于面向对象的语言，也就是说，JS并非真正的面向对象，相对的，Java，PHP5以上等的编程语言则是真正面向对象的、真正意义上的面向对象语言。所以这里通过对PHP语言的继承的学习来延伸到对JS继承的学习。</p>
<p>PHP是一门常用的后端开发语言，因为学习JS的继承，让我有机会第一次接触到这门语言。PHP的工作过程就是服务器先读取PHP文件，把服务器端的标记（如<?php ...?>）里面的内容选出来运行，再把结果返回来给客户端，所以客户端看不到服务端程序的源码，这就是PHP保密性好的原因。出于只是为了帮助对JS继承的学习的出发点，所以只对PHP一些简单语法进行学习与了解。PHP中用echo来进行输出，跟JS中的alert作用是一样的；PHP定义变量一定要用美元符号，如定义值为12 的变量a，则写作“$a=12”。PHP有两个比较特别的地方，其一，在PHP中，字符串两边可以不加引号，如“echo abc”；其二，JS中要连接两个字符串可以使用加号，但是PHP中加号只能是数字相加，所以要做字符串连接要用点，如“$a.$b”。那么又有新的疑问出现了，PHP中用点来连接两个字符串，点在JS中常用来访问对象的属性，那么PHP中用什么符号访问对象的属性呢？答案是-&gt;，如“$this-&gt;name”。PHP学起来还是蛮有意思的。</p>
<p>接下来就是学习PHP的继承。所谓继承，就是从已有的类去派生出新的类，说白点就是把其他类的内容copy过来，再加上自己的东西，由此产生属于自己的类。对象由属性和方法组成，所以要继承一个对象，需要继承那个对象的属性和方法。PHP的继承是先创建一个父类，里面添加好属性和方法，然后用extends关键字让子类去继承父类的属性和方法，再添加子类自己独有的属性和方法，最终形成独有的子类。过程其实并不难。</p>
<p>最后由PHP的继承类比到JS的继承，同样的先创建一个父类，利用构造函数添加其属性，利用原型添加其方法。接着也是利用extends关键字让子类去继承父类，通过调用父类的构造函数来继承父类的属性，这里采用call方法，如“Person.call(this,name,sex);”；通过原型来继承父类的方法，如“Worker.prototype=Person.prototype;”。然后添加子类自己的属性和方法，一个完整的子类就创建好了。JS的继承里面涉及到两个重要的知识点，call()方法和原型链，这将通过后续的学习再进一步掌握。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongoose的基本使用</title>
    <url>/2016/12/18/Mongoose%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;<strong>MongoDB</strong> 是一个对象数据库，它没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储。在MongoDB中，多个文档(Document)可以组成集合(Collection)，多个集合又可以组成数据库。<br>&emsp;&emsp;<strong>Mongoose</strong>是MongoDB的一个对象模型工具,也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。</p>
<h2 id="安装及引用"><a href="#安装及引用" class="headerlink" title="安装及引用"></a>安装及引用</h2><h3 id="安装mongoose"><a href="#安装mongoose" class="headerlink" title="安装mongoose"></a>安装mongoose</h3><p><code>npm install mongoose</code></p>
<h3 id="引用mongoose"><a href="#引用mongoose" class="headerlink" title="引用mongoose"></a>引用mongoose</h3><p><code>var mongoose = require(&quot;mongoose&quot;);</code></p>
<h3 id="使用”mongoose”连接数据库"><a href="#使用”mongoose”连接数据库" class="headerlink" title="使用”mongoose”连接数据库"></a>使用”mongoose”连接数据库</h3><p><code>var db = mongoose.connect(&quot;mongodb://user:pass@localhost:port/database&quot;);</code></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>&emsp;&emsp;一种以文件形式存储的数据库模型骨架，不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型，又或者是“集合”的模型骨架。<br>&emsp;&emsp;基本属性类型有：字符串、日期型、数值型、布尔型、null、数组、内嵌文档等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mongoose &#x3D; require(&quot;mongoose&quot;);</span><br><span class="line">var TestSchema &#x3D; new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;, &#x2F;&#x2F;属性name,类型为String</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,      &#x2F;&#x2F;属性age,类型为Number,默认为0</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;,</span><br><span class="line">    email: &#123; type:String,default:&#39;&#39;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>&emsp;&emsp;由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过Schema来创建Model</span><br><span class="line">var db &#x3D; mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);</span><br><span class="line">var TestModel &#x3D; db.model(&quot;test1&quot;, TestSchema);   &#x2F;&#x2F; 创建Model</span><br><span class="line">&#x2F;&#x2F;test1为数据库中的集合名称，添加数据时如果test1已经存在，则会保存到其目录下，如果未存在，则会创建test1集合，然后再保存数据。</span><br></pre></td></tr></table></figure>

<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>&emsp;&emsp;由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用Model创建Entity</span><br><span class="line">var TestEntity &#x3D; new TestModel(&#123;</span><br><span class="line">       name : &quot;Lenka&quot;,</span><br><span class="line">       age  : 36,</span><br><span class="line">       email: &quot;lenka@qq.com&quot;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(TestEntity.name);   &#x2F;&#x2F; Lenka</span><br><span class="line">console.log(TestEntity.age);  &#x2F;&#x2F; 36</span><br></pre></td></tr></table></figure>


<h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><h3 id="Model保存"><a href="#Model保存" class="headerlink" title="Model保存"></a>Model保存</h3><p>&emsp;&emsp;Model.create(文档数据, callback));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model.create(&#123; name:&quot;model_create&quot;, age:26&#125;, function(error,doc)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="Entity保存"><a href="#Entity保存" class="headerlink" title="Entity保存"></a>Entity保存</h3><p>&emsp;&emsp;Entity.save(文档数据, callback));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Entity &#x3D; new Model(&#123;name:&quot;entity_save&quot;,age: 27&#125;);</span><br><span class="line">Entity.save(function(error,doc) &#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>注意：</strong> model调用的是create方法，entity调用的是save方法。</p>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>&emsp;&emsp;根据条件更新相关数据。<br>&emsp;&emsp;&emsp;&emsp;obj.update(查询条件,更新对象,callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var conditions &#x3D; &#123;name : &#39;test_update&#39;&#125;; </span><br><span class="line">var update &#x3D; &#123;$set : &#123; age : 16 &#125;&#125;;</span><br><span class="line">TestModel.update(conditions, update, function(error)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;Update success!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>&emsp;&emsp;根据条件删除相关数据。<br>&emsp;&emsp;&emsp;&emsp;obj.remove(查询条件,callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var conditions &#x3D; &#123; name: &#39;tom&#39; &#125;; </span><br><span class="line">TestModel.remove(conditions, function(error)&#123;</span><br><span class="line">    if(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;Delete success!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>


<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><h4 id="find查询"><a href="#find查询" class="headerlink" title="find查询"></a>find查询</h4><p>&emsp;&emsp;返回符合条件一个、多个或者空数组文档结果。<br>&emsp;&emsp;&emsp;&emsp;obj.find(查询条件,callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model.find(&#123;&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);&#x2F;&#x2F;没有向find传递参数，默认的是显示所有文档</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">Model.find(&#123; &quot;age&quot;: 28 &#125;, function (error, docs) &#123;</span><br><span class="line">  if(error)&#123;</span><br><span class="line">     console.log(&quot;error :&quot; + error);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">     console.log(docs); &#x2F;&#x2F;显示 age为28的所有文档</span><br><span class="line">  &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<h4 id="find过滤查询"><a href="#find过滤查询" class="headerlink" title="find过滤查询"></a>find过滤查询</h4><p>&emsp;&emsp;可以过滤返回结果所显示的属性个数。<br>&emsp;&emsp;&emsp;&emsp;find(Conditions,field,callback); 其中field省略或为Null，则返回所有属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回只包含一个键值name、age的所有记录</span><br><span class="line">Model.find(&#123;&#125;,&#123;name:1, age:1, _id:0&#125;，function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把要显示的数据设置为大于0 的数即可，通常设置为1；_id是默认返回，不显示则设置为0.但是，对于非 _id的属性不显示的话不可以设置为0，否则会抛异常或查询无果。</p>
<h4 id="findOne查询"><a href="#findOne查询" class="headerlink" title="findOne查询"></a>findOne查询</h4><p>&emsp;&emsp;只返回第一个符合条件的文档数据。<br>&emsp;&emsp;&emsp;&emsp;findOne(Conditions,callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询符合age等于27的第一条数据</span><br><span class="line">TestModel.findOne(&#123; age: 27&#125;, function (err, doc)&#123;</span><br><span class="line">       console.log(doc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="findById查询"><a href="#findById查询" class="headerlink" title="findById查询"></a>findById查询</h4><p>&emsp;&emsp;只接收文档的_id作为参数，返回单个文档。<br>&emsp;&emsp;&emsp;&emsp;findById(_id, callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TestModel.findById(&#39;obj._id&#39;, function (err, doc)&#123;</span><br><span class="line">    console.log(doc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="gt-gt-、-lt-lt-、-lte-lt-、-gte-gt-操作符"><a href="#gt-gt-、-lt-lt-、-lte-lt-、-gte-gt-操作符" class="headerlink" title="$gt(&gt;)、$lt(&lt;)、$lte(&lt;=)、$gte(&gt;=)操作符"></a>$gt(&gt;)、$lt(&lt;)、$lte(&lt;=)、$gte(&gt;=)操作符</h4><p>&emsp;&emsp;针对Number类型的查询具有超强的排除性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询所有age大于18的数据</span><br><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;查询所有age小于60的数据</span><br><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$lt&quot;:60&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">     console.log(docs);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;查询所有age大于等于18小于60的数据</span><br><span class="line">Model.find(&#123;&quot;age&quot;:&#123;&quot;$gte&quot;:18,&quot;$lt&quot;:60&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="ne-操作符"><a href="#ne-操作符" class="headerlink" title="$ne(!=)操作符"></a>$ne(!=)操作符</h4><p>&emsp;&emsp;相当于不等于、不包含，查询时可根据单个或多个属性进行结果排除。$ne可以匹配单个值，也可以匹配不同类型的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询age不等于24的所有数据</span><br><span class="line">Model.find(&#123; age:&#123; $ne:24&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;查询name不等于tom、age&gt;&#x3D;18的所有数据</span><br><span class="line">Model.find(&#123;name:&#123;$ne:&quot;tom&quot;&#125;,age:&#123;$gte:18&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="in操作符"><a href="#in操作符" class="headerlink" title="$in操作符"></a>$in操作符</h4><p>&emsp;&emsp;查找包含于指定字段条件的数据。和$ne操作符用法相同，但意义相反。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询age等于20的所有数据</span><br><span class="line">Model.find(&#123; age:&#123; $in: 20&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;查询age为20和30的所有数据</span><br><span class="line">Model.find(&#123; age:&#123;$in:[20,30]&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<h4 id="or操作符"><a href="#or操作符" class="headerlink" title="$or操作符"></a>$or操作符</h4><p>&emsp;&emsp;可查询多个条件，只要满足其中一个就可返回结果值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询name为yaya或age为28的全部文档</span><br><span class="line">Model.find(&#123;&quot;$or&quot;:[&#123;&quot;name&quot;:&quot;yaya&quot;&#125;,&#123;&quot;age&quot;:28&#125;]&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="exists操作符"><a href="#exists操作符" class="headerlink" title="$exists操作符"></a>$exists操作符</h4><p>&emsp;&emsp;主要用于判断某些属性是否存在。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询所有存在name属性的文档</span><br><span class="line">Model.find(&#123;name: &#123;$exists: true&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;查询所有不存在telephone属性的文档</span><br><span class="line">Model.find(&#123;telephone: &#123;$exists: false&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">  console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>&emsp;&emsp;对数据库返回的find执行结果进行控制，可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作。主要包括限制返回结果的数量(limit函数)、忽略一点数量的结果(skip函数)以及排序(sort函数)。</p>
<h3 id="limit函数"><a href="#limit函数" class="headerlink" title="limit函数"></a>limit函数</h3><p>&emsp;&emsp;限制返回结果的数量（limit函数指定的是上限而非下限）。<br>&emsp;&emsp;&emsp;&emsp;find(Conditions,fields,options,callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;以age为条件、过滤属性为null的所有文档，限制文档数量为20</span><br><span class="line">Model.find(&#123;age:27&#125;,null,&#123;limit:20&#125;,function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;如果匹配的结果不到20个，则返回匹配数量的结果。</span><br></pre></td></tr></table></figure>

<h3 id="skip函数"><a href="#skip函数" class="headerlink" title="skip函数"></a>skip函数</h3><p>&emsp;&emsp;略过指定数量的匹配结果，返回余下的查询结果。<br>&emsp;&emsp;&emsp;&emsp;find(Conditions,fields,options,callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;跳过前4条查询结果，只返回剩下的查询结果</span><br><span class="line">Model.find(&#123;&#125;,null,&#123;skip:4&#125;,function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;如果查询结果数量中少于4个的话，则不会返回任何结果。</span><br></pre></td></tr></table></figure>

<h3 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h3><p>&emsp;&emsp;对返回结果进行有效排序。该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序。<br>&emsp;&emsp;&emsp;&emsp;find(Conditions,fields,options,callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询所有数据，并按照age降序顺序返回数据docs</span><br><span class="line">Model.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;,function(err,docs)&#123;</span><br><span class="line">        console.log(docs);</span><br><span class="line"> &#125;);</span><br><span class="line">&#x2F;&#x2F;查询所有文档(只显示属性name和age)且按照age升序展示结果</span><br><span class="line">TestModel.find(&#123;&#125;,</span><br><span class="line">               &#123;name: 1, age: 1, _id: 0 &#125;,</span><br><span class="line">               &#123;sort:&#123;age: 1 &#125;&#125;,</span><br><span class="line">               function(err,docs)&#123;</span><br><span class="line">                     console.log(docs);</span><br><span class="line">                &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h2><p>&emsp;&emsp;每一个文档都有一个主键“_id”，这个键在文档所属的集合中是唯一的。这个主键名称是固定的，默认是ObjectId类型，该类型的值由系统自己生成。<br>&emsp;&emsp;ObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，依次代表：4字节：UNIX时间戳；3字节：表示运行MongoDB的机器；2字节：表示生成此_id的进程；3字节：由一个随机数开始的计数器生成的值</p>
<h3 id="为Schema添加属性值"><a href="#为Schema添加属性值" class="headerlink" title="为Schema添加属性值"></a>为Schema添加属性值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">var TempSchema &#x3D; new mongoose.Schema;</span><br><span class="line">TempSchema.add(&#123;</span><br><span class="line">     name: &#39;String&#39;, </span><br><span class="line">     email: &#39;String&#39;, </span><br><span class="line">     age: &#39;Number&#39; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Schema实例方法"><a href="#Schema实例方法" class="headerlink" title="Schema实例方法"></a>Schema实例方法</h3><p>&emsp;&emsp;为后面的Model和Entity提供公共的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">var saySchema &#x3D; new mongoose.Schema(&#123;name : String&#125;);</span><br><span class="line">saySchema.method(&#39;say&#39;, function () &#123;</span><br><span class="line">     console.log(&#39;hello&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">var say &#x3D; mongoose.model(&#39;say&#39;, saySchema);</span><br><span class="line">var h &#x3D; new say();</span><br><span class="line">h.say();  &#x2F;&#x2F;hello</span><br></pre></td></tr></table></figure>

<h3 id="Schema静态方法"><a href="#Schema静态方法" class="headerlink" title="Schema静态方法"></a>Schema静态方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mongoose &#x3D; require(&quot;mongoose&quot;);</span><br><span class="line">var db &#x3D; mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);</span><br><span class="line">var TestSchema &#x3D; new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;,</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,</span><br><span class="line">    email: &#123; type:String, default:&quot;&quot; &#125;,</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line">TestSchema.static(&#39;findByName&#39;, function (name, callback) &#123;</span><br><span class="line">    return this.find(&#123; name: name &#125;, callback);</span><br><span class="line">&#125;);</span><br><span class="line">var TestModel &#x3D; db.model(&quot;test1&quot;, TestSchema );</span><br><span class="line">&#x2F;&#x2F;查询所有名字叫tom的文档结果集</span><br><span class="line">TestModel.findByName(&#39;tom&#39;, function (err, docs) &#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Schema追加方法"><a href="#Schema追加方法" class="headerlink" title="Schema追加方法"></a>Schema追加方法</h3><p>&emsp;&emsp;有时因为场景的需要，需要为Schema模型追加方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;为Schema模型追加speak方法</span><br><span class="line">var mongoose &#x3D; require(&quot;mongoose&quot;);</span><br><span class="line">var db &#x3D; mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);</span><br><span class="line">var TestSchema &#x3D; new mongoose.Schema(&#123;</span><br><span class="line">    name : &#123; type:String &#125;,</span><br><span class="line">    age  : &#123; type:Number, default:0 &#125;,</span><br><span class="line">    email: &#123; type:String, default:&quot;&quot; &#125;,</span><br><span class="line">    time : &#123; type:Date, default:Date.now &#125;</span><br><span class="line">&#125;);</span><br><span class="line">TestSchema.methods.speak &#x3D; function()&#123;</span><br><span class="line">    console.log(&#39;我的名字叫&#39;+this.name);</span><br><span class="line">&#125;</span><br><span class="line">var TestModel &#x3D; db.model(&#39;test1&#39;,TestSchema);</span><br><span class="line">var TestEntity &#x3D; new TestModel(&#123;name:&#39;Lenka&#39;&#125;); </span><br><span class="line">TestEntity.speak();   &#x2F;&#x2F;我的名字叫Lenka</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 编程规范</title>
    <url>/2016/10/14/Node.js-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;其实并没有一个官方的文档规定Node.js应用程序代码的风格，但Node.js代码分割有着一些“事实上的约定”，大多数项目的代码都一定程度上遵循了这一标准。 所以遵守这些约定还是有一定的必要的，因为它可能会让你的程序避免很多意外的错误和性能损失。</p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>&emsp;&emsp;选择<strong>两空格</strong>作为Node.js代码的缩进标记。为什么不用常见的四空格缩进呢？因为Node.js代码中很容易写出深层的函数嵌套，过多的空格会给阅读带来不便。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确的缩进</span><br><span class="line">function func(boolVar) &#123;</span><br><span class="line">   if (boolVar) &#123;</span><br><span class="line">     console.log(&#x27;True&#x27;);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     console.log(&#x27;False&#x27;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//错误的缩进</span><br><span class="line">function func(boolVar)</span><br><span class="line">&#123;</span><br><span class="line">     if (boolVar)</span><br><span class="line">    &#123;</span><br><span class="line">       console.log(&#x27;True&#x27;);</span><br><span class="line">     &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       console.log(&#x27;False&#x27;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="行宽"><a href="#行宽" class="headerlink" title="行宽"></a>行宽</h2><p>&emsp;&emsp;建议把行宽限制为<strong>80个字符</strong>，可以保证在任何设备上都可以方便地阅读。</p>
<h2 id="语句分隔符"><a href="#语句分隔符" class="headerlink" title="语句分隔符"></a>语句分隔符</h2><p>&emsp;&emsp; JavaScript不仅支持像C语言一样的分号<code>; </code>作为语句之间的分隔符，还支持像Python语言那样的换行作为语句之间的界限。但是建议一律使用<strong>分号</strong>，哪怕一行只有一个语句，也不要省略分号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确的语句分隔</span><br><span class="line">var a = 1;</span><br><span class="line">var b = &#x27;world&#x27;;</span><br><span class="line">var c = function(x) &#123;</span><br><span class="line">    console.log(&#x27;hello &#x27; + x + a);</span><br><span class="line">&#125;;</span><br><span class="line">c(b);</span><br><span class="line"></span><br><span class="line">//错误的语句分隔</span><br><span class="line">var a = 1</span><br><span class="line">var b = &#x27;world&#x27;</span><br><span class="line">var c = function(x) &#123;</span><br><span class="line">    console.log(&#x27;hello &#x27; + x + a)</span><br><span class="line">&#125;</span><br><span class="line">c(b)</span><br></pre></td></tr></table></figure>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>（1）不要通过赋值隐式定义变量，因为通过赋值隐式定义的变量总是全局变量，会造成命名空间污染。所以要通过 <code>var</code> 把所有变量定义为局部变量。<br>（2）使用<code>var</code>定义多个变量时，不要通过逗号<code>, </code>把多个变量隔开。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确的变量定义格式</span><br><span class="line">var foo;</span><br><span class="line">var bar;</span><br><span class="line">var arr = [40, &#x27;foo&#x27;];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//错误的变量定义格式</span><br><span class="line">var foo, bar;</span><br><span class="line">var arr = [40, &#x27;foo&#x27;],</span><br><span class="line">obj = &#123;&#125;; </span><br></pre></td></tr></table></figure>
<h2 id="变量名和属性名"><a href="#变量名和属性名" class="headerlink" title="变量名和属性名"></a>变量名和属性名</h2><p>&emsp;&emsp;使用<strong>小驼峰式命名法</strong>作为所有变量和属性的命名规则。小驼峰式命名法，即第一个单字以小写字母开始，第二个单字的首字母大写，如firstName。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确的命名</span><br><span class="line">var yourName = &#x27;BYVoid&#x27;;</span><br><span class="line"></span><br><span class="line">//错误的命名</span><br><span class="line">var YourName = &#x27;BYVoid&#x27;;</span><br><span class="line">//或者</span><br><span class="line">var your_name = &#x27;BYVoid&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>&emsp;&emsp;对于<strong>一般的函数</strong>我们使用小驼峰式命名法。但对于<strong>对象的构造函数</strong>名称（或者不严格地说“类”的名称），使用大驼峰式命名法。大驼峰式命名法，即每一个单字的首字母都采用大写字母，如FirstName。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确</span><br><span class="line">var someFunction = function() &#123;</span><br><span class="line">   return &#x27;something&#x27;;</span><br><span class="line">&#125;;</span><br><span class="line">function anotherFunction() &#123;</span><br><span class="line">   return &#x27;anything&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">function DataStructure() &#123;</span><br><span class="line">   this.someProperty = &#x27;initialized&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//错误</span><br><span class="line">var SomeFunction = function()</span><br><span class="line">&#123;</span><br><span class="line">   return &#x27;something&#x27;;</span><br><span class="line">&#125;;</span><br><span class="line">function another_function () &#123;</span><br><span class="line">   return &#x27;anything&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">function dataStructure() &#123;</span><br><span class="line">this.someProperty = &#x27;initialized&#x27;;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>&emsp;&emsp;在JavaScript中单引号<code>&#39; </code>和双引号<code>&quot; </code>没有任何语义区别，两者都是可用的。建议用<strong>单引号</strong>，因为JSON、 XML都规定了必须是双引号，这样便于无转义地直接引用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确的引号用法</span><br><span class="line">console.log(&#x27;Hello world.&#x27;);</span><br><span class="line"></span><br><span class="line">//错误的引号用法</span><br><span class="line">console.log(&quot;Hello world.&quot;); </span><br></pre></td></tr></table></figure>
<h2 id="关联数组的初始化"><a href="#关联数组的初始化" class="headerlink" title="关联数组的初始化"></a>关联数组的初始化</h2><p>&emsp;&emsp;按<code>var = &#123; 放在一行，下面每行一对键值，保持两空格的缩进，以分号结尾， &#125;; </code>的形式，最后单独另起一行。对于每对键值，除非键名之中有空格或者有非法字符，否则一律不用引号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确</span><br><span class="line">var anObject = &#123;</span><br><span class="line">    name: &#x27;BYVoid&#x27;,</span><br><span class="line">    website: &#x27;http://www.byvoid.com/&#x27;,</span><br><span class="line">    &#x27;is good&#x27;: true,</span><br><span class="line">&#125;;</span><br><span class="line">//错误</span><br><span class="line">    var anObject = &#123;&#x27;name&#x27;: &#x27;BYVoid&#x27;,</span><br><span class="line">    website: &#x27;http://www.byvoid.com/&#x27;</span><br><span class="line">    , &quot;is good&quot;: true&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="等号"><a href="#等号" class="headerlink" title="等号"></a>等号</h2><p>&emsp;&emsp;尽量使用 <code>=== </code>而不是<code>==</code>来判断相等，因为<code> ==</code> 包含了隐式类型转换，很多时候可能会出错。</p>
<h2 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a>命名函数</h2><p>&emsp;&emsp;尽量给构造函数和回调函数命名。对于回调函数，Node.js的API和各个第三方的模块通常约定回调函数的第一个参数是错误对象<code>err</code>，如果没有错误发生，其值为 <code>undefined</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确</span><br><span class="line">req.on(&#x27;end&#x27;, function onEnd(err, message) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">    console.log(&#x27;Error.&#x27;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">function FooObj() &#123;</span><br><span class="line">    this.foo = &#x27;bar&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//错误</span><br><span class="line">req.on(&#x27;end&#x27;, function (message, err) &#123;</span><br><span class="line">    if (err === false) &#123;</span><br><span class="line">      console.log(&#x27;Error.&#x27;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var FooObj = function() &#123;</span><br><span class="line">this.foo = &#x27;bar&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象定义"><a href="#对象定义" class="headerlink" title="对象定义"></a>对象定义</h2><p>&emsp;&emsp;尽量将所有的成员函数通过原型定义，将属性在构造函数内定义，然后对构造函数使用<code>new </code>关键字创建对象。避免把成员函数定义在构造函数内部，否则会有运行时的闭包开销。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确:</span><br><span class="line">function FooObj(bar) &#123;</span><br><span class="line">//在构造函数中初始化属性</span><br><span class="line">    this.bar = bar;</span><br><span class="line">    this.arr = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">//使用原型定义成员函数</span><br><span class="line">FooObj.prototype.func = function() &#123;</span><br><span class="line">    console.log(this.arr);</span><br><span class="line">&#125;;</span><br><span class="line">var obj1 = new FooObj(&#x27;obj1&#x27;);</span><br><span class="line">var obj2 = new FooObj(&#x27;obj2&#x27;);</span><br><span class="line">obj1.arr.push(4);</span><br><span class="line">obj1.func(); // [1, 2, 3, 4]</span><br><span class="line">obj2.func(); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">//错误：</span><br><span class="line">function FooObj(bar) &#123;</span><br><span class="line">    this.bar = bar;</span><br><span class="line">this.func = function() &#123;</span><br><span class="line">    console.log(this.arr);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">FooObj.prototype.arr = [1, 2, 3];</span><br><span class="line">var obj1 = new FooObj(&#x27;obj1&#x27;);</span><br><span class="line">var obj2 = new FooObj(&#x27;obj2&#x27;);</span><br><span class="line">obj1.arr.push(4);</span><br><span class="line">obj1.func(); // [1, 2, 3, 4]</span><br><span class="line">obj2.func(); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>&emsp;&emsp;避免使用复杂的<strong>继承</strong>，如果的确需要继承，那么尽量使用Node.js的util模块中提供的<code>inherits</code>函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var util = require(&#x27;util&#x27;);</span><br><span class="line">var events = require(&#x27;events&#x27;);</span><br><span class="line">function Foo() &#123;</span><br><span class="line">   &#125;</span><br><span class="line">util.inherits(Foo, events.EventEmitter); //让Foo继承EventEmitter</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs之Url模块&amp;QueryString模块</title>
    <url>/2016/09/13/Nodejs%E4%B9%8BUrl%E6%A8%A1%E5%9D%97&amp;QueryString%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="Url模块"><a href="#Url模块" class="headerlink" title="Url模块"></a>Url模块</h2><h3 id="url-parse-urlStr-parseQueryString-slashesDenoteHost"><a href="#url-parse-urlStr-parseQueryString-slashesDenoteHost" class="headerlink" title="url.parse(urlStr, [parseQueryString], [slashesDenoteHost])"></a>url.parse(urlStr, [parseQueryString], [slashesDenoteHost])</h3><p>将URL字符串转换为对象。有3个参数：</p>
<ul>
<li>urlStr： url字符串。</li>
<li>parseQueryString：可选。设置为true时，会使用querystring模块来解析URL中德查询字符串部分，默认为 false。</li>
<li>slashesDenoteHost：可选。默认为false，//foo/bar 形式的字符串将被解释成 { pathname: ‘//foo/bar’ }；<br>如果设置成true，//foo/bar 形式的字符串将被解释成  { host: ‘foo’, pathname: ‘/bar’ }。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">url.parse(&#x27;http://www.jb51.net/article/61637.htm&#x27;)</span><br><span class="line">//结果</span><br><span class="line">url &#123;</span><br><span class="line">  protocol: &#x27;http:&#x27;,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: &#x27;www.jb51.net&#x27;,</span><br><span class="line">  port: null,</span><br><span class="line">  hostname: &#x27;www.jb51.net&#x27;,</span><br><span class="line">  hash: null,</span><br><span class="line">  search: null,</span><br><span class="line">  query: null,</span><br><span class="line">  pathname: &#x27;/article/61637.htm&#x27;,</span><br><span class="line">  path: &#x27;/article/61637.htm&#x27;,</span><br><span class="line">  href: &#x27;http://www.jb51.net/article/61637.htm&#x27; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="url-format-urlObj"><a href="#url-format-urlObj" class="headerlink" title="url.format(urlObj)"></a>url.format(urlObj)</h3>将对象格式化为URL字符串，与url.parse()方法刚好相反。只有1个参数——urlObj，表示 URL对象。<br>下面代码会将一串对象格式化为URL字符串：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">url.format(&#123;protocol: &#x27;http:&#x27;,slashes: true,auth: null,host: &#x27;www.jb51.net&#x27;,port: null,hostname: &#x27;www.jb51.net&#x27;,hash: null,search: null,query: null, pathname: &#x27;/article/61637.htm&#x27;,path: &#x27;/article/61637.htm&#x27;,href:&#x27;http://www.jb51.net/article/61637.htm&#x27;&#125;)</span><br><span class="line">//结果</span><br><span class="line">&#x27;http://www.jb51.net/article/61637.htm&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="url-resolve-from-to"><a href="#url-resolve-from-to" class="headerlink" title="url.resolve(from, to)"></a>url.resolve(from, to)</h3>为URL或 href 插入或替换原有的标签。有2个参数:</li>
<li>from：源地址。</li>
<li>to：需要添加或替换的标签。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">url.resolve(&#x27;/one/two&#x27;,&#x27;three&#x27;)</span><br><span class="line">//结果</span><br><span class="line">&#x27;/one/three&#x27;</span><br><span class="line"></span><br><span class="line">url.resolve(&#x27;http://example.com&#x27;,&#x27;two&#x27;)</span><br><span class="line">//结果</span><br><span class="line">&#x27;http://example.com/two&#x27;</span><br><span class="line"></span><br><span class="line">url.resolve(&#x27;http://example.com/two&#x27;,&#x27;three&#x27;)</span><br><span class="line">//结果</span><br><span class="line">&#x27;http://example.com/three&#x27;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="QueryString模块"><a href="#QueryString模块" class="headerlink" title="QueryString模块"></a>QueryString模块</h2><h3 id="querystring-stringify-obj-sep-eq"><a href="#querystring-stringify-obj-sep-eq" class="headerlink" title="querystring.stringify(obj, [sep], [eq])"></a>querystring.stringify(obj, [sep], [eq])</h3><p>将对象转换成字符串，字符串里多个参数将用 ‘&amp;’ 分隔，将用 ‘=’ 赋值。有3个参数：</p>
<ul>
<li>obj： 欲转换的对象。</li>
<li>sep：可选。设置分隔符，默认为 ‘&amp;’。</li>
<li>eq：可选。设置赋值符，默认为 ‘=’。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">querystring.stringify(&#123;name:&#x27;rose&#x27;,sex:&#x27;girl&#x27;&#125;)</span><br><span class="line">//结果</span><br><span class="line">&#x27;name=rose&amp;sex=girl&#x27;</span><br><span class="line"></span><br><span class="line">querystring.stringify(&#123;name:&#x27;rose&#x27;,sex:&#x27;girl&#x27;&#125;,&#x27;;&#x27;,&#x27;:&#x27;)//用分号分隔，用冒 号赋值</span><br><span class="line">//结果</span><br><span class="line">&#x27;name:rose;sex:girl&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="querystring-parse-str-sep-eq-options"><a href="#querystring-parse-str-sep-eq-options" class="headerlink" title="querystring.parse(str, [sep], [eq], [options])"></a>querystring.parse(str, [sep], [eq], [options])</h3>与querystring.stringify()刚好相反，将字符串转换成对象。有4个参数：</li>
<li>str：欲转换的字符串。</li>
<li>sep：可选。设置分隔符，默认为 ‘&amp;’。</li>
<li>eq：可选。设置赋值符，默认为 ‘=’。</li>
<li>options：maxKeys可接受字符串的最大长度，默认为1000，如果将其设置为0则表示没这个限制。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">querystring.parse(&#x27;name=rose&amp;sex=girl&#x27;)</span><br><span class="line">//结果</span><br><span class="line">&#123; name: &#x27;rose&#x27;, sex: &#x27;girl&#x27; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="querystring-escape"><a href="#querystring-escape" class="headerlink" title="querystring.escape()"></a>querystring.escape()</h3>转义。将传入的字符串进行编码返回相应的编码串。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">querystring.escape(&#x27;&lt;哈哈&gt;&#x27;)</span><br><span class="line">//结果</span><br><span class="line">&#x27;%3C%E5%93%88%E5%93%88%3E&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="querystring-unescape"><a href="#querystring-unescape" class="headerlink" title="querystring.unescape()"></a>querystring.unescape()</h3>反转义。将传入的编码字符串反转回原始字符串。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">querystring.unescape(&#x27;%3C%E5%93%88%E5%93%88%3E&#x27;)</span><br><span class="line">//结果</span><br><span class="line">&#x27;&lt;哈哈&gt;&#x27;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>URL模块&amp;queryString模块</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP实训总结</title>
    <url>/2016/12/08/PHP%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;结课考试后，学校安排了一次为期10天的实训，实训方向有安卓和PHP，我选择了PHP，因为PHP跟前端还是有关系的。实训虽然讲的内容不多，但还是从中得到一些收获，并最终做出一个包含增删改查功能的简历投递系统，特此写个总结。</p>
<h2 id="PHP环境配置"><a href="#PHP环境配置" class="headerlink" title="PHP环境配置"></a>PHP环境配置</h2><p>&emsp;&emsp;主要用到三个软件：PhpStorm—-开发工具，phpStudy—-开发环境，Navicat for MySQL—-MySQL数据库。</p>
<h3 id="phpStudy的安装"><a href="#phpStudy的安装" class="headerlink" title="phpStudy的安装"></a>phpStudy的安装</h3><ol>
<li>点击安装包，一直next直至安装完成。</li>
<li>打开phpStudy—&gt;其他选项菜单—&gt;打开配置文件—&gt;找到vhosts.conf文件—&gt;粘贴配置代码—&gt;保存—&gt;重启phpStudy。配置代码如下(其中路径为phpstudy安装目录下www文件所在的路径，如<code>D:\phpstudy\WWW</code>，域名可以自己取，如<code>www.cxt.com</code>)：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    DocumentRoot &quot;路径&quot;</span><br><span class="line">    ServerName 域名</span><br><span class="line">  &lt;Directory &quot;路径&quot;&gt;</span><br><span class="line">      Options +Indexes +FollowSymLinks +ExecCGI</span><br><span class="line">      AllowOverride All</span><br><span class="line">      Order allow,deny</span><br><span class="line">      Allow from all</span><br><span class="line">      Require all granted</span><br><span class="line">  &lt;&#x2F;Directory&gt;</span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure></li>
<li>找到路径 <code>C:\Windows\System32\drivers\etc\hosts</code>，对hosts文件进行配置：在最后一行加上<code>127.0.0.1 域名</code>。</li>
<li>打开phpStudy—&gt;其他选项菜单—&gt;PHP扩展及配置—&gt;PHP扩展—&gt;将php_openssl打钩。</li>
<li>通过域名或者路径“127.0.1.1”或者路径“localhost”打开浏览器，会有欢迎方面，表示安装成功。</li>
<li>如果想创建多个域名，只要参照(1)(2)步下来即可。</li>
</ol>
<h3 id="PhpStorm的安装"><a href="#PhpStorm的安装" class="headerlink" title="PhpStorm的安装"></a>PhpStorm的安装</h3><ol>
<li>点击安装包，一直next直至安装完成。</li>
<li>打开PhpStorm—&gt;输入以下License进行破解：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User name:</span><br><span class="line">        EMBRACE</span><br><span class="line"></span><br><span class="line">     License key:</span><br><span class="line">        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; LICENSE BEGIN &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        43136-12042010随机加上一串数字，防止验证码冲突(数字随便写几个)</span><br><span class="line">        00002UsvSON704l&quot;dILe1PVx3y4&quot;B3</span><br><span class="line">        49AU6oSDJrsjE8nMOQh&quot;8HTDJHIUUh</span><br><span class="line">        gd1BebYc5U&quot;6OxDbVsALB4Eb10PW8&quot;</span><br><span class="line">        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; LICENSE END &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></li>
<li>将软件关闭进行汉化：找到phpstorm安装位置，找到里面的<code>\lib\messages</code>,把汉化包<code>resources_cn.jar</code>放入进去，重启phpstrom，即可发现汉化成功。</li>
</ol>
<h3 id="Navicat-for-MySQL的安装"><a href="#Navicat-for-MySQL的安装" class="headerlink" title="Navicat for MySQL的安装"></a>Navicat for MySQL的安装</h3><ol>
<li>点击安装包，一直next直至安装完成。</li>
<li>打开数据库—&gt;连接—&gt;设置连接名和密码都为<code>root</code>—&gt;连接测试—&gt;确定测试成功。</li>
<li>根据需要创建数据库和表。</li>
</ol>
<h2 id="MySQL常用语句"><a href="#MySQL常用语句" class="headerlink" title="MySQL常用语句"></a>MySQL常用语句</h2><h3 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h3><p>格式：insert  into  表名（字段1，字段2，字段3……）values(值1，值2，值3……)<br>如：<code>insert into type(name) values (&#39;生物&#39;)</code></p>
<h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><p>格式：select 字段1，字段2，……from  表名<br>&emsp;&emsp;字段之间用<code>,</code>隔开，如果查询所有的字段用<code>*</code>来代替。<br>如：<code>select * from books</code></p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>格式：update  表名  set 字段名1=‘新值1’，字段名2=‘新值2’ where=’条件’<br>&emsp;&emsp;如果不加where条件那么将会把所有的记录的值都修改掉。<br>如：update type set name=’生物’ where name=’地理’</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>格式：delete  from  表名 where 条件<br>&emsp;&emsp;如果不加where条件那么将会把所有的记录都删除掉。<br>如：delete from type where name=’生物’</p>
<h2 id="PHP知识点"><a href="#PHP知识点" class="headerlink" title="PHP知识点"></a>PHP知识点</h2><p>&emsp;&emsp;这里只列举一些本次实训所用到的PHP知识点。</p>
<ol>
<li>PHP中所有的变量必须用<code>$</code>来修饰</li>
<li>php定界符是<code>&lt;?php ?&gt;</code>，也就是说PHP代码中以<code>&lt;?php</code>开始，以<code>?&gt;</code>结束。</li>
<li>隐藏域：不会显示在页面上，但是会被提交过去。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;’hidden’ name&#x3D;’hide’value&#x3D;“eeee”&gt;  &#x2F;&#x2F;php接收:$_POST[‘hide’]</span><br></pre></td></tr></table></figure></li>
<li><code>$_POST[]</code>接收所有以<code>post</code>方式传递的值，<code>$_GET[]</code>接收所有以<code>get</code>方式传递的值。</li>
<li>mysql_query() 函数：执行一条 MySQL 查询。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$data&#x3D;mysql_query($sql);</span><br></pre></td></tr></table></figure></li>
<li>mysql_fetch_assoc() 函数：从结果集中取得一行作为关联数组,其实就是将取得的结果以数组形式返回。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$data&#x3D;mysql_fetch_assoc($data);</span><br></pre></td></tr></table></figure></li>
<li>include文件：将 PHP 文件的内容插入到另一个 PHP 文件中。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include(&quot;mysql.php&quot;);</span><br></pre></td></tr></table></figure></li>
<li>die(status) 函数：输出一条消息，并退出当前脚本。如果 status 是字符串，则该函数会在退出前输出字符串；如果 status 是整数，这个值会被用作退出状态。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$link&#x3D;mysql_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;) or die(&quot;数据库连接失败&quot;);&#x2F;&#x2F;连接数据库</span><br></pre></td></tr></table></figure></li>
<li>isset()函数： 一般用来检测变量是否设置。若变量已存在则返回 true 值。其它情形返回 false 值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$tel&#x3D;isset($_POST[&quot;tel&quot;])?$_POST[&quot;tel&quot;]:&quot;&quot;;&#x2F;&#x2F;三元运算符，如果变量值未设置就返回空值</span><br></pre></td></tr></table></figure></li>
<li>explode()：将字符串分割成为数组.有两个参数，第一个是分割符号，第二个是字符串名，返回值为一个分割后的新数组。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$arr&#x3D;explode(&quot;.&quot;,$_FILES[&quot;myfile&quot;][&quot;name&quot;]);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;通过完成一个简单的小项目–<a href="https://github.com/chen-xt/resume">简历投递系统</a>，我发现用PHP做增删改查功能的原理大致是：处理页面去获取用户提交的值或者路径的参数值，然后执行sql语句，再转入指定的结果显示的页面。而且经常需要手动去添加路径的参数值，以便能被获取到。<br>&emsp;&emsp;明白了原理之后再去做项目其实并不会特别难，但是常常因为变量未获取，sql语句语法出现错误等等各种原因导致错误，所以在敲代码的时候认真细心还是非常重要的，这点还需要后面慢慢去培养。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>实训总结</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap-datetimepicker日期插件</title>
    <url>/2017/07/18/bootstrap-datetimepicker%E6%97%A5%E6%9C%9F%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Bootstrap下的datetimepicker插件是一款日期选择器插件，使用起来方便而且界面也是很好看的。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>&emsp;&emsp;时间格式，默认值为<code>mm/dd/yyyy</code>。有几种格式：</p>
<ol>
<li>yyyy-mm-dd</li>
<li>yyyy-mm-dd hh:ii</li>
<li>yyyy-mm-ddThh:ii</li>
<li>yyyy-mm-dd hh:ii:ss</li>
<li>yyyy-mm-ddThh:ii:ssZ<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">format: &#39;yyyy-mm-dd hh:ii&#39; &#x2F;&#x2F;时间显示到分钟</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="weekStart"><a href="#weekStart" class="headerlink" title="weekStart"></a>weekStart</h3><p>&emsp;&emsp;默认值为0。一周从哪一天开始0（星期日）到6（星期六）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weekStart:  &#39;1&#39;	&#x2F;&#x2F;一周从周一开始</span><br></pre></td></tr></table></figure>

<h3 id="startDate"><a href="#startDate" class="headerlink" title="startDate"></a>startDate</h3><p>&emsp;&emsp;开始时间。可以选择的最早日期，这个日期之前的日期都无法被选择。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startDate: &#39;2017-08-15 14:45&#39; 	&#x2F;&#x2F;选择的日期最早只能是这个</span><br></pre></td></tr></table></figure>

<h3 id="endDate"><a href="#endDate" class="headerlink" title="endDate"></a>endDate</h3><p>&emsp;&emsp;结束时间。可能选择的最新日期，这个日期以后的日期都无法被选择。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">endDate: &#39;2017-09-08 14:45&#39;	   &#x2F;&#x2F;选择的日期最新只能是这个</span><br></pre></td></tr></table></figure>

<h3 id="daysOfWeekDisabled"><a href="#daysOfWeekDisabled" class="headerlink" title="daysOfWeekDisabled"></a>daysOfWeekDisabled</h3><p>&emsp;&emsp;禁用星期几。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daysOfWeekDisabled: &#39;0,6&#39;	&#x2F;&#x2F;禁用周末，周六、周日的日期无法被选择</span><br></pre></td></tr></table></figure>

<h3 id="autoclose"><a href="#autoclose" class="headerlink" title="autoclose"></a>autoclose</h3><p>&emsp;&emsp;默认值为false，不关闭。当选择好一个日期之后是否立即关闭此日期时间选择器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoclose: &#39;true&#39;	&#x2F;&#x2F;选好日期后关闭日期时间选择器</span><br></pre></td></tr></table></figure>

<h3 id="startView"><a href="#startView" class="headerlink" title="startView"></a>startView</h3><p>&emsp;&emsp;默认值为2, 首先显示的视图是月份视图。0是小时视图，1是日视图，2是月份视图，3是年视图，4是十年视图。日期时间选择器打开之后首先显示的视图。0小时或小时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startView:  &#39;1&#39;    &#x2F;&#x2F;日视图</span><br></pre></td></tr></table></figure>

<h3 id="minView"><a href="#minView" class="headerlink" title="minView"></a>minView</h3><p>&emsp;&emsp;默认值为0，小时视图。日期时间选择器所能够提供的最精确的时间选择视图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minView: &#39;1&#39;   &#x2F;&#x2F;最精确是到日视图</span><br></pre></td></tr></table></figure>

<h3 id="maxView"><a href="#maxView" class="headerlink" title="maxView"></a>maxView</h3><p>&emsp;&emsp;默认值为4，十年视图。日期时间选择器最高能展示的选择范围视图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxView: &#39;1&#39;   &#x2F;&#x2F;最高能展示的是日视图</span><br></pre></td></tr></table></figure>

<h3 id="todayBtn"><a href="#todayBtn" class="headerlink" title="todayBtn"></a>todayBtn</h3><p>&emsp;&emsp;默认值为false。如果此值为true 或 “linked”，则在日期时间选择器组件的底部显示一个 <code>Today</code> 按钮用以选择当前日期。如果是true的话，<code>Today</code>按钮仅仅将视图转到当天的日期，如果是<code>linked</code>，当天日期将会被选中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">todayBtn: &#39;true&#39;</span><br></pre></td></tr></table></figure>

<h3 id="keyboardNavigation"><a href="#keyboardNavigation" class="headerlink" title="keyboardNavigation"></a>keyboardNavigation</h3><p>&emsp;&emsp;默认值为true。是否允许通过方向键改变日期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keyboardNavigation: &#39;false&#39;  &#x2F;&#x2F;无法通过方向键改变日期</span><br></pre></td></tr></table></figure>

<h3 id="minuteStep"><a href="#minuteStep" class="headerlink" title="minuteStep"></a>minuteStep</h3><p>&emsp;&emsp;默认值为5。小时视图中的可以选择的分钟数间隔为5分钟。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minuteStep: &#39;10&#39;</span><br></pre></td></tr></table></figure>

<h3 id="showMeridian"><a href="#showMeridian" class="headerlink" title="showMeridian"></a>showMeridian</h3><p>&emsp;&emsp;默认值为false。用于小时视图和日视图，为true视图会显示上下午（AM，PM）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">showMeridian: &#39;true&#39;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>&emsp;&emsp;.datetimepicker(options)：初始化日期时间选择器。options的值有以下几个值可以选择。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>&emsp;&emsp;无参数，移除日期时间选择器。同时移除已经绑定的event、内部绑定的对象和HTML元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(‘.form_datetime’).datetimepicker(&#39;remove&#39;);  &#x2F;&#x2F;视图无法显示。时间无法选择</span><br></pre></td></tr></table></figure>

<h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><p>&emsp;&emsp;无参数，显示日期时间选择器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(‘.form_datetime’).datetimepicker(&#39;show&#39;);  &#x2F;&#x2F;页面一加载，视图就已经显示</span><br></pre></td></tr></table></figure>

<h3 id="hide"><a href="#hide" class="headerlink" title="hide"></a>hide</h3><p>&emsp;&emsp;无参数，隐藏日期时间选择器。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(‘.form_datetime’).datetimepicker(&#39;hide&#39;);  &#x2F;&#x2F;页面加载完成时，视图是隐藏的</span><br></pre></td></tr></table></figure>

<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>&emsp;&emsp;无参数，使用当前输入框中的值更新日期时间选择器。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(‘.form_datetime’).datetimepicker(&#39;update&#39;); </span><br></pre></td></tr></table></figure>

<h3 id="setStartDate"><a href="#setStartDate" class="headerlink" title="setStartDate"></a>setStartDate</h3><p>&emsp;&emsp;startDate (String)。给日期时间选择器设置一个新的起始日期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.form_datetime&quot;).datetimepicker(&#39;setStartDate&#39;, &#39;2012-01-01&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="setEndDate"><a href="#setEndDate" class="headerlink" title="setEndDate"></a>setEndDate</h3><p>&emsp;&emsp;endDate (String)。给日期时间选择器设置结束日期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.form_datetime&quot;).datetimepicker(&#39;setEndDate&#39;, &#39;2012-01-01&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="setDaysOfWeekDisabled"><a href="#setDaysOfWeekDisabled" class="headerlink" title="setDaysOfWeekDisabled"></a>setDaysOfWeekDisabled</h3><p>&emsp;&emsp;daysOfWeekDisabled (String|Array)。设置禁用日期，无法被选择的日期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.form_datetime&quot;).datetimepicker(&#39;setDaysOfWeekDisabled&#39;, [0,6]);         </span><br></pre></td></tr></table></figure>

<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="show-1"><a href="#show-1" class="headerlink" title="show"></a>show</h3><p>&emsp;&emsp;当选择器显示时被触发。</p>
<h3 id="hide-1"><a href="#hide-1" class="headerlink" title="hide"></a>hide</h3><p>&emsp;&emsp;当选择器隐藏时被触发。</p>
<h3 id="changeDate"><a href="#changeDate" class="headerlink" title="changeDate"></a>changeDate</h3><p>&emsp;&emsp;当日期被改变时被触发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;#date-end&#39;)</span><br><span class="line"> .datetimepicker()</span><br><span class="line">   .on(&#39;changeDate&#39;, function(ev)&#123;</span><br><span class="line">    if (ev.date.valueOf() &lt; date-start-display.valueOf())&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="changeYear"><a href="#changeYear" class="headerlink" title="changeYear"></a>changeYear</h3><p>&emsp;&emsp;当十年视图上的年视图被改变时触发。</p>
<h3 id="changeMonth"><a href="#changeMonth" class="headerlink" title="changeMonth"></a>changeMonth</h3><p>&emsp;&emsp;当年视图上的月视图被改变时触发。</p>
<h3 id="outOfRange"><a href="#outOfRange" class="headerlink" title="outOfRange"></a>outOfRange</h3><p>&emsp;&emsp;当用户选择的日期超出<code>startDate</code>或<code>endDate</code>时，或者通过<code>setDate</code> 或<code>setUTCDate</code>方法设置日期超出范围时被触发。</p>
<h2 id="键盘支持"><a href="#键盘支持" class="headerlink" title="键盘支持"></a>键盘支持</h2><h3 id="up-down-left-right方向键"><a href="#up-down-left-right方向键" class="headerlink" title="up/down/left/right方向键"></a>up/down/left/right方向键</h3><p>&emsp;&emsp;<code>left/right</code>向后/向前 一天，<code>up/down</code>向后/向前一周。配合shift键，<code>up/left</code>向后退一个月，<code>down/right</code>向前进一个月。配置ctrl键，<code>up/left</code>向后退一年，<code>down/right</code> 向前进一年。<code>Shift+ctrl</code>和<code>ctrl</code>同等效果，即不能同时改变月和年，只能单独改变年。</p>
<h3 id="escape键"><a href="#escape键" class="headerlink" title="escape键"></a>escape键</h3><p>&emsp;&emsp;可以用来隐藏、重新显示日期时间选择器。</p>
<h3 id="enter键"><a href="#enter键" class="headerlink" title="enter键"></a>enter键</h3><p>&emsp;&emsp;当选择器处于显示状态时，enter键只是将其隐藏。当选择器处于隐藏状态时，enter键发挥通常的功能 - 提交当前表单，或者其他。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>绑定输入框，并设置format选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;2012-05-15 21:05&quot; class&#x3D;&quot;form_datetime&quot;&gt;</span><br><span class="line"></span><br><span class="line">$(&#39;.form_datetime&#39;).datetimepicker(&#123;</span><br><span class="line">    format: &#39;yyyy-mm-dd hh:ii&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定输入框，并设置format标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;2012-05-15 21:05&quot; class&#x3D;&quot;form_datetime&quot; data-date-format&#x3D;&quot;yyyy-mm-dd hh:ii&quot;&gt;</span><br><span class="line"></span><br><span class="line">$(&#39;.form_datetime&#39;).datetimepicker();</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为组件使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;input-append date&quot; class&#x3D;&quot;form_datetime&quot; data-date&#x3D;&quot;12-02-2012&quot; data-date-format&#x3D;&quot;dd-mm-yyyy&quot;&gt;</span><br><span class="line">    &lt;input size&#x3D;&quot;16&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;12-02-2012&quot; readonly&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;add-on&quot;&gt;&lt;i class&#x3D;&quot;icon-th&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">$(&#39;.form_datetime&#39;).datetimepicker();</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为内联日期时间选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;form_datetime&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">$(&#39;.form_datetime&#39;).datetimepicker();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.bootcss.com/p/bootstrap-datetimepicker/index.htm">参考网址</a></li>
</ul>
]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>datetimepicker</tag>
      </tags>
  </entry>
  <entry>
    <title>get和post的区别</title>
    <url>/2016/08/17/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>HTTP（超文本传输协议）的设计目的是保证客户机与服务器之间的通信。它的两种最常用的 HTTP 方法是：get和post。下面就这两种方法的一些主要区别进行分析。</p>
<h2 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h2><ul>
<li><strong>get请求：</strong>一般用于获取/查询资源信息，从指定的资源请求数据。</li>
<li><strong>post请求：</strong>一般用于更新资源信息，向指定的资源提交要被处理的数据。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><strong>get请求：</strong>请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。get的数据类型只限ASCII编码，也就是说所有的非ASCII字符都要编码之后再传输。</li>
<li><strong>post请求：</strong>请求的数据会被放置在HTTP请求包的包体中。post的数据类型没有限制，可以是ASCII编码，也可以是二进制数据。<br>因此，get请求的数据会暴露在地址栏中，而post请求则不会。</li>
</ul>
<h2 id="传输数据的大小"><a href="#传输数据的大小" class="headerlink" title="传输数据的大小"></a>传输数据的大小</h2><ul>
<li><strong>get请求：</strong>在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于get，特定的浏览器和服务器对URL的长度有限制。因此，在使用get请求时，传输数据会受到URL长度的限制。</li>
<li><strong>post请求：</strong>对于post，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对post提交数据大小进行限制，Apache、IIS都有各自的配置。</li>
</ul>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul>
<li><strong>get请求：</strong>与 POST 相比，get的安全性较差，因为所发送的数据是URL的一部分。比如，在进行登录操作，通过get请求，用户名和密码都会暴露在URL上，因为登录页面有可能被浏览器缓存或者被其他人查看浏览器的历史记录，所以用户名和密码就很容易被他人拿到了。</li>
<li><strong>post请求：</strong>post的安全性比get的高，因为参数不会被保存在浏览器历史或 web 服务器日志中。</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li><strong>get请求：</strong>在发送后,能被缓存；</li>
<li><strong>post请求：</strong>在发送后,不能被缓存。</li>
</ul>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>get-post</tag>
      </tags>
  </entry>
  <entry>
    <title>github 和 gitblit 并存</title>
    <url>/2019/09/17/github%20%E5%92%8C%20gitblit%20%E5%B9%B6%E5%AD%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;由于工作需要，一台电脑需要同时存在 github 和 gitblit 账号，因为需要配置多个 ssh key，以满足个人和工作上的需要。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="分别创建-github-和-gitblit-账号的公钥"><a href="#分别创建-github-和-gitblit-账号的公钥" class="headerlink" title="分别创建 github 和 gitblit 账号的公钥"></a>分别创建 github 和 gitblit 账号的公钥</h2><ol>
<li><p>创建 github 账号公钥<br>&emsp;&emsp;输入命令 <code>ssh-keygen -t rsa -C &quot;GitEmail@example.com&quot;</code>，然后 enter 键。（图略）<br>&emsp;&emsp;这里先不要回车，输入<code>/Users/cxiaoting/.ssh/id_rsa_github</code>（id_rsa_github 为自定义的名字），然后 enter 键，会提示输入 2 次密码，根据实际情况输入密码即可。</p>
</li>
<li><p>创建 gitblit 账号公钥<br>&emsp;&emsp;输入命令<code>ssh-keygen -t rsa -C &quot;GitEmail@example.com&quot;</code>，然后 enter 键。（图略）<br>&emsp;&emsp;这里先不要回车，输入<code>/Users/cxiaoting/.ssh/id_rsa_gitblit</code>（id_rsa_gitblit 为自定义的名字），然后 enter 键，会提示输入 2 次密码，根据实际情况输入密码即可。</p>
</li>
</ol>
<h2 id="创建并配置-config-文件"><a href="#创建并配置-config-文件" class="headerlink" title="创建并配置 config 文件"></a>创建并配置 config 文件</h2><ol>
<li>打开.ssh 目录<br>&emsp;&emsp;输入命令<code>open ~/.ssh</code>，进入.ssh 目录。</li>
<li>创建 config 文件<br>&emsp;&emsp;输入命令<code>touch config</code>，将以下内容复制进去到 config 文件中，其中 username 为账户名。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_github</span><br><span class="line">User username1</span><br><span class="line"></span><br><span class="line">Host gitblit</span><br><span class="line">HostName gitblit.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_gitblit</span><br><span class="line">User username2</span><br></pre></td></tr></table></figure>

<h2 id="将公钥添加到系统"><a href="#将公钥添加到系统" class="headerlink" title="将公钥添加到系统"></a>将公钥添加到系统</h2><ol>
<li>把 2 个账号公钥添加到系统<br>&emsp;&emsp;输入命令<code>ssh-add id_rsa_gitblit id_rsa_github</code>，然后会提示你分别输入两个账号的密码，按照提示输入。</li>
<li>查看 2 个公钥是否成功添加到系统<br>&emsp;&emsp;输入命令<code>ssh-add -l</code>，添加成功则会显示 2 条记录。</li>
</ol>
<h2 id="将公钥添加到线上的-sshkey"><a href="#将公钥添加到线上的-sshkey" class="headerlink" title="将公钥添加到线上的 sshkey"></a>将公钥添加到线上的 sshkey</h2><p>&emsp;&emsp;这里举例 github 账号,新建一个 ssh key，然后将 id_rsa_github.pub 的内容（即公钥）复制一份放到对应的 key 里面，保存。gitblit 账号也是同样的做法。（图略）</p>
<h2 id="测试连接是否成功"><a href="#测试连接是否成功" class="headerlink" title="测试连接是否成功"></a>测试连接是否成功</h2><p>&emsp;&emsp;测试 github 账号，输入命令<code>ssh -T git@github</code>；测试 gitblit 账号，输入命令<code>ssh -T git@gitblit</code>,出现如下图即表示成功。（图略）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;成功完成以上步骤，就可以无需账号密码，尽情操作 github 和 gitblit 了。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>layer弹层组件之移动版</title>
    <url>/2017/08/31/layer%E5%BC%B9%E5%B1%82%E7%BB%84%E4%BB%B6%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%89%88/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;layer弹层组件分移动版和PC版，这边主要讲的是移动版的layer，PC版的后续再进行补充。移动版是为移动设备量身定做的弹层UI，并且完全独立于PC版的layer。与PC版的layer不同的是，移动版的layer只提供一个核心调用方法，即<code>layer.open(options)</code>，通过对参数<code>options</code>进行设置来实现各种不同的弹层。</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>&emsp;&emsp;第一步，下载。要去<a href="http://layer.layui.com/mobile/">官网</a>下载layer的相关文件，主要是<code>layer.js</code>文件，<code>layer.css</code>文件可以根据需要引入，但是<code>layer.js</code>文件是必需的。<br>&emsp;&emsp;第二步，引入。将layer的相关文件引入项目中，这里需要注意的是，不能去挪动layer里面的文件结构，因为它们是不可拆散的组合，直接整个引入就可以。由于layer是基于jQuery的，在引入<code>layer.js</code>文件之前，必须先引入<strong>jQuery1.8</strong>或以上版本。<br>&emsp;&emsp;第三步，使用。下面是一个简单的layer弹层例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">	  &lt;title&gt;开始使用layer&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;&#x2F;head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">	  &lt;button id&#x3D;&quot;test&quot;&gt;小小提示层&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">	  &lt;script src&#x3D;&quot;jQuery的路径&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">	  &lt;script src&#x3D;&quot;layer.js的路径&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">	  &lt;script&gt;</span><br><span class="line">		$(&#39;#test&#39;).on(&#39;click&#39;, function()&#123;</span><br><span class="line">		  layer.open(&#123;</span><br><span class="line">			type: 1,</span><br><span class="line">			area: [&#39;600px&#39;, &#39;360px&#39;],</span><br><span class="line">			shadeClose: true, &#x2F;&#x2F;点击遮罩关闭</span><br><span class="line">			content: &#39;\&lt;\div style&#x3D;&quot;padding:20px;&quot;&gt;自定义内容\&lt;\&#x2F;div&gt;&#39;</span><br><span class="line">		  &#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	  &lt;&#x2F;script&gt;</span><br><span class="line">	&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt; </span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>&emsp;&emsp;这里所谈到的参数指的就是核心接口<code>layer.open(options)</code>中的<strong>options</strong>。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>&emsp;&emsp;type参数用于设置弹层的类型。其类型为<code>Number</code>型，默认值为<code>0</code>（<strong>0</strong>表示信息框，<strong>1</strong>表示页面层，<strong>2</strong>表示加载层）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: 1</span><br></pre></td></tr></table></figure>

<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>&emsp;&emsp;content参数用于设置弹层内容。其类型为<code>String</code>型，这个参数为必选参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content:  &#39;layer弹层组件&#39;  </span><br></pre></td></tr></table></figure>

<h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>&emsp;&emsp;title参数用于设置弹层标题。其类型为<code>String</code>型或<code>Array</code>型，默认值为<code>空</code>，值可以为字符串或者数组，为空则不显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;格式</span><br><span class="line">	title: &#39;标题&#39;</span><br><span class="line">	title: [&#39;标题&#39;, &#39;background-color: #eee;&#39;] &#x2F;&#x2F;第二个参数可以自定义标题的样式 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">	title:  &#39;layer&#39;</span><br><span class="line">	title:  [&#39;layer&#39;, &#39;color: #eee;&#39;]  </span><br></pre></td></tr></table></figure>

<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>&emsp;&emsp;time参数用于控制自动关闭层所需秒数。其类型为<code>Number</code>型，默认不开启，支持整数和浮点数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time:  5  &#x2F;&#x2F;5秒后关闭  </span><br></pre></td></tr></table></figure>

<h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p>&emsp;&emsp;style参数用于设置自定义层的样式。其类型为<code>String</code>型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style:  &#39;border:none; background-color:#78BA32; color:#fff;&#39;  </span><br></pre></td></tr></table></figure>

<h3 id="skin"><a href="#skin" class="headerlink" title="skin"></a>skin</h3><p>&emsp;&emsp;skin参数用于设定弹层显示风格。其类型为<code>String</code>型，目前支持配置<code>footer</code>(即底部对话框风格)、<code>msg</code>(普通提示)两种风格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skin: &#39;footer&#39;  </span><br></pre></td></tr></table></figure>

<h3 id="className"><a href="#className" class="headerlink" title="className"></a>className</h3><p>&emsp;&emsp;className参数用于自定义一个css类。其类型为<code>String</code>型，用于自定义样式。自定义一个css类后，就可以在css里面通过设置这个类的样式来控制该弹层的风格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">className:  &#39;modal&#39;  </span><br></pre></td></tr></table></figure>

<h3 id="btn"><a href="#btn" class="headerlink" title="btn"></a>btn</h3><p>&emsp;&emsp;btn参数用于设置按钮。其类型为<code>String</code>型或<code>Array</code>型，不设置则不显示按钮。如果只需要一个按钮，则<code>btn: &#39;按钮&#39;</code>，如果有两个，则<code>btn: [&#39;按钮一&#39;, &#39;按钮二&#39;]</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置两个按钮</span><br><span class="line">btn:  [&#39;马上开启&#39;,&#39;稍后再说&#39; ]  </span><br></pre></td></tr></table></figure>

<h3 id="anim"><a href="#anim" class="headerlink" title="anim"></a>anim</h3><p>&emsp;&emsp;anim参数用于设置动画类型。其类型为<code>String</code>型或<code>Boolean</code>型，可支持的支持两种动画配置<code>scale</code>(默认)和<code>up</code>(从下往上弹出)，如果不开启动画，设置<code>false</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anim:  &#39;up&#39;</span><br></pre></td></tr></table></figure>

<h3 id="shade"><a href="#shade" class="headerlink" title="shade"></a>shade</h3><p>&emsp;&emsp;shade参数用于控制遮罩展现。其类型为<code>String</code>型或<code>Boolean</code>型，默认为<code>true</code>，显示遮罩，并且可以自定义遮罩风格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shade:  &#39;background-color: rgba(0,0,0,.6) &#39;  &#x2F;&#x2F;遮罩的颜色以及透明度</span><br></pre></td></tr></table></figure>

<h3 id="shadeClose"><a href="#shadeClose" class="headerlink" title="shadeClose"></a>shadeClose</h3><p>&emsp;&emsp;shadeClose参数用于设置点击遮罩时是否关闭层。其类型为<code>Boolean</code>型，默认为<code>true</code>，即点击遮罩时关闭层。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shadeClose:  false  &#x2F;&#x2F;点击遮罩时不关闭层  </span><br></pre></td></tr></table></figure>

<h3 id="fixed-amp-amp-top"><a href="#fixed-amp-amp-top" class="headerlink" title="fixed &amp;&amp;  top"></a>fixed &amp;&amp;  top</h3><p>&emsp;&emsp;fixed参数用于设置是否固定层的位置，需要与top参数一起使用。其类型为<code>Boolean</code>型，默认为<code>true</code>，不固定层的位置。而top参数用于控制层的纵坐标，其类型为<code>Number</code>型，默认为<code>无</code>，一般情况下不需要设置，因为层会始终垂直水平居中，只有当<code>fixed: false</code>时top才有效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fixed : false,</span><br><span class="line">top: 10</span><br></pre></td></tr></table></figure>

<h3 id="success-amp-amp-end"><a href="#success-amp-amp-end" class="headerlink" title="success &amp;&amp;  end"></a>success &amp;&amp;  end</h3><p>&emsp;&emsp;success参数用于设置层成功弹出层的回调，该回调参数返回一个参数为当前层元素对象。其类型为<code>Function</code>型。end参数与success参数用法类似，只是它刚好与success参数相反，是用于设置层彻底销毁后的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;格式</span><br><span class="line">	success: function(elem)&#123;</span><br><span class="line">		console.log(elem);   &#x2F;&#x2F;弹层成功弹出时候提示弹出	</span><br><span class="line">	&#125;</span><br><span class="line">	end: function(elem)&#123;</span><br><span class="line">		console.log(elem);   &#x2F;&#x2F;弹层销毁时提示销毁</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">	success: function()&#123;</span><br><span class="line">		alert(&#39;弹出&#39;);   </span><br><span class="line">	&#125;,</span><br><span class="line">	end:function(index)&#123;</span><br><span class="line">		  alert(&quot;销毁&quot;); </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="yes-amp-amp-no"><a href="#yes-amp-amp-no" class="headerlink" title="yes &amp;&amp;  no"></a>yes &amp;&amp;  no</h3><p>&emsp;&emsp;yes参数用于设置点击确定按钮触发的回调函数，返回一个参数为当前层的索引。其类型为<code>Function</code>型。no参数与yes参数用法类似，只是它刚好与yes参数相反，用于设置点击取消按钮触发的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;格式：</span><br><span class="line">	yes: function(index)&#123;</span><br><span class="line">	  alert(&#39;点击了是&#39;)</span><br><span class="line">	  layer.close(index)</span><br><span class="line">	&#125;</span><br><span class="line">	no: function(index)&#123;</span><br><span class="line">	  alert(&#39;点击了否&#39;)</span><br><span class="line">	  layer.close(index)</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">	yes: function()&#123;  &#x2F;&#x2F;点击确定时候弹出“好的”提示</span><br><span class="line">	    layer.open(&#123;</span><br><span class="line">	      content: &#39;好的&#39;</span><br><span class="line">	      ,time: 2</span><br><span class="line">	      ,skin: &#39;msg&#39;</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	no: function(index)&#123;			  </span><br><span class="line">		window.location.href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;; &#x2F;&#x2F;点击取消跳转到必应</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其它内置方法-属性"><a href="#其它内置方法-属性" class="headerlink" title="其它内置方法/属性"></a>其它内置方法/属性</h2><h3 id="layer-v"><a href="#layer-v" class="headerlink" title="layer.v"></a>layer.v</h3><p>&emsp;&emsp;layer.v用于返回当前使用的layer mobile版本号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yes: function(index)&#123;</span><br><span class="line">    alert(layer.v);   &#x2F;&#x2F;弹出“2.0”，当前的版本为2.0</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="layer-close-index"><a href="#layer-close-index" class="headerlink" title="layer.close(index)"></a>layer.close(index)</h3><p>&emsp;&emsp;layer.close(index)用于关闭特定层，index为该特定层的索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yes: function(index)&#123;</span><br><span class="line">	layer.close(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="layer-closeAll"><a href="#layer-closeAll" class="headerlink" title="layer.closeAll()"></a>layer.closeAll()</h3><p>&emsp;&emsp;layer.closeAll()用于关闭页面所有layer的层。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yes: function(index)&#123;</span><br><span class="line">    layer.closeAll();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li><p>信息框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer.open(&#123;</span><br><span class="line">    content: &#39;我是layer移动版&#39;,</span><br><span class="line">    btn: &#39;知道了&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer.open(&#123;</span><br><span class="line">    content: &#39;你好&#39;,</span><br><span class="line">    skin: &#39;msg&#39;,</span><br><span class="line">    time: 3 &#x2F;&#x2F;3秒后自动关闭</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>询问框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer.open(&#123;</span><br><span class="line">    content: &#39;您确定要刷新一下本页面吗？&#39;,</span><br><span class="line">    btn: [&#39;刷新&#39;, &#39;不要&#39;],</span><br><span class="line">    yes: function(index)&#123;</span><br><span class="line">      location.reload();</span><br><span class="line">      layer.close(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>底部对话框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer.open(&#123;</span><br><span class="line">    content: &#39;这是一个底部弹出的询问提示&#39;,</span><br><span class="line">    btn: [&#39;删除&#39;, &#39;取消&#39;],</span><br><span class="line">    skin: &#39;footer&#39;,</span><br><span class="line">    yes: function(index)&#123;</span><br><span class="line">      layer.open(&#123;content: &#39;执行删除操作&#39;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer.open(&#123;</span><br><span class="line">    type: 1,</span><br><span class="line">    content: &#39;可传入任何内容，支持html。一般用于手机页面中&#39;,</span><br><span class="line">    anim: &#39;up&#39;,</span><br><span class="line">    style: &#39;position:fixed; bottom:0; left:0; width: 100%; height: 200px; padding:10px 0; border:none;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>loading带文字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer.open(&#123;</span><br><span class="line">    type: 2,</span><br><span class="line">    content: &#39;加载中&#39; &#x2F;&#x2F;如果没有content的话，则只有几个加载的小圆点</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><ul>
<li><a href="http://layer.layui.com/mobile/api.html">参考网址</a></li>
</ul>
]]></content>
      <categories>
        <category>layer</category>
      </categories>
      <tags>
        <tag>layer</tag>
      </tags>
  </entry>
  <entry>
    <title>mac支持rz及sz</title>
    <url>/2020/04/23/mac%E6%94%AF%E6%8C%81rz%E5%8F%8Asz/</url>
    <content><![CDATA[<h2 id="安装-brew"><a href="#安装-brew" class="headerlink" title="安装 brew"></a>安装 brew</h2><p>&emsp;&emsp;进入<a href="https://brew.sh/">官网</a>，按照一步步操作即可。</p>
<h2 id="安装-lrzs"><a href="#安装-lrzs" class="headerlink" title="安装 lrzs"></a>安装 lrzs</h2><p>&emsp;&emsp;执行命令<code>brew install lrzs</code>进行安装，安装完成后到 <code>/usr/local/bin</code> 路径下查看是否存在 sz 及 rz，存在则表示安装成功。</p>
<p><strong>tips</strong></p>
<p>若安装时遇到 Updating Homebrew…长时间卡住，可以通过关闭自动更新解决，步骤如下：</p>
<ol>
<li>打开配置文件：<code>open .bash_profile</code></li>
<li>在打开的配置文件中黏贴命令<code>export HOMEBREW_NO_AUTO_UPDATE=true</code>，关闭自动更新</li>
<li>执行命令<code>source .bash_profile</code>保存配置文件，重新执行配置文件</li>
</ol>
<h2 id="安装-item2"><a href="#安装-item2" class="headerlink" title="安装 item2"></a>安装 item2</h2><p>&emsp;&emsp;进入<a href="https://iterm2.com/">官网</a>，按照一步步操作即可。</p>
<h2 id="安装-iterm2-zmodem"><a href="#安装-iterm2-zmodem" class="headerlink" title="安装 iterm2-zmodem"></a>安装 iterm2-zmodem</h2><p>&emsp;&emsp;手动添加这个<code>iterm2-send-zmodem.sh</code>和<code>iterm2-recv-zmodem.sh</code>2 个脚本文件到<code>/usr/local/bin/</code>路径下，并使用命令<code>chmod 777 iterm2-recv-zmodem.sh</code>和<code>chmod 777 iterm2-send-zmodem.sh</code>分别分配权限。脚本内容可参照<a href="https://www.bookstack.cn/read/mac-best-app/iTerm2-01.md">地址</a>。</p>
<h2 id="配置-item2"><a href="#配置-item2" class="headerlink" title="配置 item2"></a>配置 item2</h2><p><img src="/images/content/macSet1.png" alt="配置图1"><br><img src="/images/content/macSet2.png" alt="配置图2"><br><strong>附 triggers 中填入的文本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Regular expression: \*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">Regular expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure>

<h2 id="参照地址"><a href="#参照地址" class="headerlink" title="参照地址"></a>参照地址</h2><ul>
<li><a href="https://www.whatled.com/post-6508.html">参照地址 1</a></li>
<li><a href="https://www.jianshu.com/p/52ff25407621">参照地址 2</a></li>
</ul>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>qrcode生成二维码</title>
    <url>/2019/01/16/qrcode%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;js 生成二维码有两种方法：分别是用 qrcode.js 和 jquery.qrcode.js。</p>
<h1 id="qrcode"><a href="#qrcode" class="headerlink" title="qrcode"></a>qrcode</h1><p>&emsp;&emsp;qrcode.js 是一个用于生成二维码图片的插件，主要是通过获取 DOM 的标签，再通过 HTML5 Canvas 绘制而成，不依赖任何库，<strong>支持中文内容</strong>。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li>载入 js 文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;qrcode.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DOM 结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;code&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单方式</span><br><span class="line">new QRCode(document.getElementById(&#39;code&#39;), &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置参数方式</span><br><span class="line">var qrcode &#x3D; new QRCode(&#39;code&#39;, &#123;</span><br><span class="line">    text: &#39;hello world!&#39;,</span><br><span class="line">    width: 200,</span><br><span class="line">    height: 200,</span><br><span class="line">    colorDark : &#39;#000&#39;,</span><br><span class="line">    colorLight : &#39;#fff&#39;,</span><br><span class="line">    correctLevel : QRCode.CorrectLevel.H</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 API</span><br><span class="line">qrcode.clear();</span><br><span class="line">qrcode.makeCode(&#39;哈哈哈&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>&emsp;&emsp;格式：<strong>new QRCode(element, option)</strong></p>
<ol>
<li>element：显示二维码的元素或该元素的 id</li>
<li>option：参数配置，有以下几个参数：<br>（1）text：设置二维码的内容；<br>（2）width：设置二维码宽度，默认值是 256；<br>（3）height：设置二维码高度，默认值是 256；<br>（4）colorDark：设置前景色，默认值是”#000”<br>（5）colorLight：设置背景色，默认值是”#fff”<br>（6）typeNumber: 设置计算模式，默认值是 4<br>（7）correctLevel : 设置容错级别，默认值是 QRErrorCorrectLevel.H，可设置为 QRCode.CorrectLevel.L(容错率 7%)、QRCode.CorrectLevel.M(容错率 15%)、QRCode.CorrectLevel.Q(容错率 25%)、QRCode.CorrectLevel.H(容错率 30%)；<br>注意：二维码容错率即是指二维码图标被遮挡多少后，仍可以被扫描出来的能力。容错率越高，则二维码图片能被遮挡的部分越多。容错率越高，越容易被快速扫描。因此推荐使用 QRErrorCorrectLevel.H。</li>
</ol>
<h2 id="API-接口"><a href="#API-接口" class="headerlink" title="API 接口"></a>API 接口</h2><ol>
<li><strong>makeCode(text)：</strong>设置二维码内容</li>
<li><strong>clear()：</strong>清除二维码（仅在不支持 Canvas 的浏览器下有效）</li>
</ol>
<h1 id="jquery-qrcode-js"><a href="#jquery-qrcode-js" class="headerlink" title="jquery.qrcode.js"></a>jquery.qrcode.js</h1><p>&emsp;&emsp;jquery.qrcode.js 是把 qrcode.js 用 jquery 方式封装起来的，用它来实现图形渲染，其实就是画图（支持 canvas 和 table 两种方式）默认是 canvas，canvas 方式还支持右键图片下载，<strong>不支持中文内容</strong>。</p>
<h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li>载入 js 文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;jquery.qrcode.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DOM 结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;code&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单方式</span><br><span class="line">&#x2F;&#x2F; $(&quot;#code&quot;).qrcode(&quot;hi,chen!&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接生成二维码</span><br><span class="line">$(&quot;#code&quot;).qrcode(&#123;</span><br><span class="line">    render: &quot;canvas&quot;, &#x2F;&#x2F;渲染方式</span><br><span class="line">    width: 200,  &#x2F;&#x2F;宽度</span><br><span class="line">    height: 200, &#x2F;&#x2F;高度</span><br><span class="line">    text: &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;, &#x2F;&#x2F;内容</span><br><span class="line">    background: &quot;#fff&quot;,  &#x2F;&#x2F;背景色</span><br><span class="line">    foreground: &quot;#000&quot;,   &#x2F;&#x2F;前景色(二维码的颜色)</span><br><span class="line">    correctLevel: 1,  &#x2F;&#x2F;容错级别</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h2><p>（1）render: 设置渲染方式，支持 canvas 和 table 两种方式，默认是 canvas；<br>（2）text：设置二维码的内容<br>（3）width：设置二维码宽度，默认值是 256；<br>（4）height：设置二维码高度，默认值是 256；<br>（5）foreground: 设置前景色，默认值是”#000”<br>（6）background: 设置背景色，默认值是”#fff”<br>（7）correctLevel : 设置容错级别<br>（8）typeNumber : 设置计算模式</p>
<h2 id="生成二维码图片"><a href="#生成二维码图片" class="headerlink" title="生成二维码图片"></a>生成二维码图片</h2><ol>
<li>载入 js 文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;jquery.qrcode.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DOM 结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;code&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;img id&#x3D;&quot;imgOne&quot; src&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;生成二维码图片</span><br><span class="line">var qrcode &#x3D; $(&#39;#code&#39;).qrcode(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;).hide();</span><br><span class="line">var canvas &#x3D; qrcode.find(&#39;canvas&#39;).get(0);</span><br><span class="line">$(&#39;#imgOne&#39;).attr(&#39;src&#39;,canvas.toDataURL(&#39;image&#x2F;jpg&#39;));</span><br></pre></td></tr></table></figure>

<h2 id="解决无法生成中文二维码的问题"><a href="#解决无法生成中文二维码的问题" class="headerlink" title="解决无法生成中文二维码的问题"></a>解决无法生成中文二维码的问题</h2><p>&emsp;&emsp;jquery-qrcode 这个库是采用 charCodeAt() 这个方式进行编码转换的，这个方法默认会获取它的 Unicode 编码，一般的解码器都是采用 UTF-8, ISO-8859-1 等方式。英文是没有问题，如果是中文，一般情况下 Unicode 是 UTF-16 实现，长度 2 位，而 UTF-8 编码是 3 位，这样二维码的编解码就不匹配了。 所以可以在二维码编码前把字符串转换成 UTF-8，就可以解决这个问题了。<br>&emsp;&emsp;相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#code&quot;).qrcode(&#123;</span><br><span class="line">      render: &quot;canvas&quot;, &#x2F;&#x2F;渲染方式</span><br><span class="line">      width: 200,  &#x2F;&#x2F;宽度</span><br><span class="line">      height: 200, &#x2F;&#x2F;高度</span><br><span class="line">      text: utf16to8(&quot;你好啊&quot;), &#x2F;&#x2F;内容</span><br><span class="line">      background: &quot;#fff&quot;,  &#x2F;&#x2F;背景色</span><br><span class="line">      foreground: &quot;#000&quot;,   &#x2F;&#x2F;前景色(二维码的颜色)</span><br><span class="line">      correctLevel: 1,  &#x2F;&#x2F;容错级别</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 编码转换函数</span><br><span class="line">  function utf16to8(str) &#123;</span><br><span class="line">      var out, i, len, c;</span><br><span class="line">      out &#x3D; &quot;&quot;;</span><br><span class="line">      len &#x3D; str.length;</span><br><span class="line">      for(i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">      c &#x3D; str.charCodeAt(i);</span><br><span class="line">      if ((c &gt;&#x3D; 0x0001) &amp;&amp; (c &lt;&#x3D; 0x007F)) &#123;</span><br><span class="line">          out +&#x3D; str.charAt(i);</span><br><span class="line">      &#125; else if (c &gt; 0x07FF) &#123;</span><br><span class="line">          out +&#x3D; String.fromCharCode(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));</span><br><span class="line">          out +&#x3D; String.fromCharCode(0x80 | ((c &gt;&gt;  6) &amp; 0x3F));</span><br><span class="line">          out +&#x3D; String.fromCharCode(0x80 | ((c &gt;&gt;  0) &amp; 0x3F));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          out +&#x3D; String.fromCharCode(0xC0 | ((c &gt;&gt;  6) &amp; 0x1F));</span><br><span class="line">          out +&#x3D; String.fromCharCode(0x80 | ((c &gt;&gt;  0) &amp; 0x3F));</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return out;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><ul>
<li><a href="http://code.ciaoca.com/javascript/qrcode/">qrcode.js 参考网址</a></li>
<li><a href="https://github.com/jeromeetienne/jquery-qrcode">jquery.qrcode.js 参考网址</a></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title>使用document.write输出覆盖HTML文档问题</title>
    <url>/2016/08/04/%E4%BD%BF%E7%94%A8document-write%E8%BE%93%E5%87%BA%E8%A6%86%E7%9B%96HTML%E6%96%87%E6%A1%A3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在W3C学习时，看到一行提示：“您只能在 HTML 输出中使用 document.write。如果您在文档加载后使用该方法，会覆盖整个文档。”感到很困惑，什么是文档加载后？为什么会覆盖整个文档？为此上网去查找了些资料。下面做下总结。</p>
<h3 id="什么情况是文档加载后？"><a href="#什么情况是文档加载后？" class="headerlink" title="什么情况是文档加载后？"></a>什么情况是文档加载后？</h3><p>HTML文档加载，是自上而下的加载HTML表示的内容，当整个页面内容都加载完毕之后，再调用document.write()这方法会导致文档上所有内容被清空，只留下 document.write 中的内容。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;after()&quot;&gt;点击这里&lt;&#x2F;button&gt; </span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    document.write(&quot;hello&quot;);</span><br><span class="line">    function after()</span><br><span class="line">    &#123;</span><br><span class="line">     document.write(&quot;点击按钮后，会清除所有 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<p>文档加载完成后，页面显示“hello”，当点击按钮后会清除并覆盖当前内容，显示“点击按钮后，会清除所有”。</p>
<h3 id="为什么将该方法嵌套在函数中，就相当于文档加载后？"><a href="#为什么将该方法嵌套在函数中，就相当于文档加载后？" class="headerlink" title="为什么将该方法嵌套在函数中，就相当于文档加载后？"></a>为什么将该方法嵌套在函数中，就相当于文档加载后？</h3><p>代码都是写在body标签中的，不是应该在加载时就执行了所有的内容，包括函数中的内容吗？其实不是这样的，如果将document.write直接写在script标签中，那么文档加载完成前会运行该代码；但是如果把document.write嵌套在函数中，则在文档加载完成前，只会声明该函数，而不会执行函数内的代码，具体函数内代码的执行，是等到文档加载完成后的。</p>
<h3 id="为什么文档加载后使用该方法，会覆盖整个文档？"><a href="#为什么文档加载后使用该方法，会覆盖整个文档？" class="headerlink" title="为什么文档加载后使用该方法，会覆盖整个文档？"></a>为什么文档加载后使用该方法，会覆盖整个文档？</h3><p>文档加载时，相当于打开一个document对象，此时如果遇到document.wirte，就会把内容加入到document中。但是当文档加载完成后，document对象就会被关闭，此时若再使用该方法，相当于重新打开一个document对象，这次打开，就会覆盖上一次打开所写的内容，对document对象进行重写。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>覆盖文档</tag>
      </tags>
  </entry>
  <entry>
    <title>初识正则表达式</title>
    <url>/2016/07/30/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>*正则表达式(RegExp)*是强大的字符串匹配工具，可以极大地简化普通字符串操作容易出问题的东西。正则表达式只能操作字符串，且区分大小写。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ol>
<li>直接量语法: /pattern/attributes<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re=<span class="regexp">/a/i</span>;</span><br></pre></td></tr></table></figure></li>
<li>创建 RegExp 对象的语法：：new RegExp(pattern, attributes);<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure>
注意：参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。参数 attributes 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。</li>
</ol>
<h4 id="RegExp对象方法："><a href="#RegExp对象方法：" class="headerlink" title="RegExp对象方法："></a>RegExp对象方法：</h4><ol>
<li>test()方法：检测一个字符串是否匹配某个模式。返回值是 true 或 false。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> patt1=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;e&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.write(patt1.test(<span class="string">&quot;The best &quot;</span>)); <span class="comment">//该字符串中存在字母 &quot;e&quot;，所以输出是true</span></span><br></pre></td></tr></table></figure></li>
<li>exec()方法：检索字符串中的正则表达式的匹配。返回值是被找到的值。如果没有发现匹配，则返回 null。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> patt1=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;e&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.write(patt1.exec(<span class="string">&quot;The best &quot;</span>)); <span class="comment">//该字符串中存在字母 &quot;e&quot;，所以输出是e</span></span><br></pre></td></tr></table></figure></li>
<li>compile()方法：改变正则表达式的模式。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在字符串中全局搜索 &quot;man&quot;，并用 &quot;person&quot; 替换。然后通过 compile() 方法，改变正则表达式，用 &quot;person&quot; 替换 &quot;man&quot; 或 &quot;woman&quot;，</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;Every man in the world! Every woman on earth!&quot;</span>;</span><br><span class="line">patt=<span class="regexp">/(wo)?man/g</span>;</span><br><span class="line">patt.compile(patt);</span><br><span class="line">Str2=str.replace(patt,<span class="string">&quot;person&quot;</span>);<span class="comment">//用 &quot;person&quot; 替换 &quot;man&quot; 或 &quot;woman&quot;，：</span></span><br><span class="line"><span class="built_in">document</span>.write(str2);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h4><ol>
<li>Search()方法：检索与正则表达式相匹配的值。不执行全局匹配，它将忽略标志 g，同时它也没有regexp对象的lastIndex的属性，且总是从字符串开始位置进行查找，总是返回匹配的第一个位置。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;hello,world!&quot;</span></span><br><span class="line"><span class="built_in">document</span>.write(str.search(<span class="regexp">/world/</span>)); <span class="comment">//结果返回6，即w所在的位置</span></span><br></pre></td></tr></table></figure></li>
<li>match()方法：找到一个或多个正则表达式的匹配,返回指定的值，而不是字符串的位置。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;abcd 3458 gea2 ef&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/\d+/g</span>));<span class="comment">//结果为3548,2</span></span><br></pre></td></tr></table></figure></li>
<li>Replace()方法：查找并替换与正则表达式匹配的子串。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;good girl&quot;</span></span><br><span class="line"><span class="built_in">document</span>.write(str.replace(<span class="regexp">/girl/</span>, <span class="string">&quot;boy&quot;</span>));<span class="comment">//使用boy替换girl</span></span><br></pre></td></tr></table></figure></li>
<li>Split()方法：把一个字符串分割为字符串数组。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;How are you ?&quot;</span></span><br><span class="line"><span class="built_in">document</span>.write(str.split(<span class="string">&quot;&quot;</span>) + <span class="string">&quot;&lt;br /&gt;&quot;</span>);<span class="comment">//结果为&quot;H,o,w, ,a,r,e, ,y,o,u, ,?&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p><em>元字符</em>是拥有特殊含义的字符，javascript中常见的元字符如下：</p>
<ol>
<li>元字符*.* ：用于匹配任何单个字符(除了换行符以外)。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = “abcde”;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/a.c/</span>)); <span class="comment">// 结果为“abc”</span></span><br></pre></td></tr></table></figure></li>
<li>\w：查找任意一个字母或数字或下划线。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = “abcde”;<span class="comment">// 匹配单个字符，找到一个直接返回</span></span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/\w/</span>)); <span class="comment">//结果为“a”</span></span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/\w+/</span>)); <span class="comment">//结果为“abcde”</span></span><br></pre></td></tr></table></figure></li>
<li>\W：查找非单词的字符.<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = “abcde”;<span class="comment">// 匹配单个字符，没有找到返回null</span></span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/\W/</span>)); <span class="comment">// 结果为“null”</span></span><br></pre></td></tr></table></figure></li>
<li>\d：匹配一个数字字符。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = “abcde111”;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="regexp">/\d/g</span>.exec(str)); <span class="comment">//结果为“1”</span></span><br></pre></td></tr></table></figure></li>
<li>\D：匹配一个非数字字符。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = “abcde111”;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="regexp">/\D+/g</span>.exec(str)); <span class="comment">//结果为“abcde”</span></span><br></pre></td></tr></table></figure></li>
<li> \s：匹配任何空白字符，包括空格，制表符，换行符等等。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=”Is <span class="built_in">this</span> all there is?”;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="regexp">/\s/g</span>.exec(str)); <span class="comment">// 结果为“ ”</span></span><br></pre></td></tr></table></figure></li>
<li>\S：匹配任何非空白字符。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=”Is <span class="built_in">this</span> all there is?”;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="regexp">/\S+/g</span>.exec(str)); <span class="comment">//结果为“Is”</span></span><br></pre></td></tr></table></figure></li>
<li>\b：匹配一个单词边界，也就是指单词和空格间的位置。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=”Is <span class="built_in">this</span> all there is?”;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="regexp">/\bthis\b/g</span>.exec(str)); <span class="comment">//结果为“this”</span></span><br></pre></td></tr></table></figure></li>
<li>\B：匹配非单词边界。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=”Is <span class="built_in">this</span> all there is?”;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="regexp">/\Bhi/g</span>.exec(str)); <span class="comment">// 结果为“hi”</span></span><br></pre></td></tr></table></figure></li>
<li>\n：匹配一个换行符;返回换行符被找到的位置。如果未找到匹配，则返回 -1。 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=”Is <span class="built_in">this</span> all \nthere is?”;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="regexp">/\n/g</span>.exec(str));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="正则的方括号"><a href="#正则的方括号" class="headerlink" title="正则的方括号"></a>正则的方括号</h4><p>方括号包含一系列字符，能够匹配其中任意一个字符,如[abc]可以匹配abc中任意一个字符，使用[^abc]包含的字符abc，则能够匹配abc字符之外的任何一个字符，只能是一个字符。常见的几种方括号的用法如下：</p>
<ul>
<li>[abc]：查找在方括号中的任意一个字符；</li>
<li>[^abc]: 查找不在方括号中的任意一个字符；</li>
<li>[0-9]: 查找0-9中的任意一个数字；</li>
<li>[a-z]: 查找从小写a到z中的任意一个字符。</li>
</ul>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><ol>
<li>n*：匹配零个或者多个n的字符串。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello longen hello&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/el*/g</span>)); <span class="comment">//结果为&quot;ell&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>n+：匹配至少包含一个或者多个n的字符串。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello longen&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/l+/g</span>)); <span class="comment">//结果为&quot;ll&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>n？：匹配零个或者1个n的字符串，可以匹配n字符串，也可以只匹配一个n；先尽量匹配，如没有匹配到，就回溯，再进行不匹配；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello longen hello&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/hu?/g</span>)); <span class="comment">//结果为&quot;h&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>n{x}：匹配包含x个的n的序列字符串。X必须是数字。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;100, 1000 or 10000?&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/\d&#123;4&#125;/g</span>)); <span class="comment">//结果为[&quot;1000&quot;, &quot;1000&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li>n{x,y}：匹配包含至少x个的n字符串，最多y个n字符串。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;100, 1000 or 10000?&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/\d&#123;3,&#125;/g</span>)); <span class="comment">//结果为[&quot;100&quot;, &quot;1000&quot;, &quot;1000&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li>n{x,}：匹配至少包含x个n序列的字符串；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;100, 1000 or 10000?&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/d&#123;3,&#125;/g</span>)); <span class="comment">//结果为[&quot;100&quot;, &quot;1000&quot;, &quot;1000&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li>n$：匹配任何以n结尾的字符串；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;my name is longen&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/en$/g</span>)); <span class="comment">//结果为[&quot;en&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li>^n：匹配任何以n开头的字符串；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;my name is longen&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/^my/g</span>)); <span class="comment">//结果为&quot;my&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>?=n：匹配任何其后紧接指定字符串n的字符串；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;my name is longen&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/na(?=m)/g</span>)); <span class="comment">//结果为&quot;na&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>?!n：匹配任何其后不紧接n的字符串 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;my name is longen&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(<span class="regexp">/na(?!ma)/g</span>)); <span class="comment">//结果为&quot;na&quot;</span></span><br></pre></td></tr></table></figure></li>
<li> ^ 以字符串开始的地方匹配，不匹配任何字符；</li>
<li>$ 以字符串结束的地方匹配，不匹配任何字符；</li>
</ol>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>正则表达式在javascript中的应用挺广泛的，可以说带来很多的方便，这里就列举两个应用：</p>
<ol>
<li><em>行首行尾去空格</em><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27; www ee  d;fl  &#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/^\s+|S+&amp;/</span>;<span class="comment">//行首行尾去空格</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;(&#x27;</span>+str.replace(re,<span class="string">&#x27;&#x27;</span>));</span><br></pre></td></tr></table></figure></li>
<li><em>校验邮箱</em><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re=<span class="regexp">/^\w+@[a-z0-9]+\.[a-z]&#123;2-4&#125;$/</span>;</span><br><span class="line">  <span class="keyword">if</span>(re.test(oTxt.value))</span><br><span class="line">    &#123;  alert(<span class="string">&#x27;right&#x27;</span>); &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">    &#123;  alert(<span class="string">&#x27;wrong&#x27;</span>);  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于node-express-multer的文件上传</title>
    <url>/2017/04/26/%E5%9F%BA%E4%BA%8Enode-express-multer%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;<strong>multer</strong>是一个用以处理 <strong>multipart/form-data</strong> 请求的node.js中间件，主要用于上传文件。它基于 busboy 开发以提供最高的性能。本篇文章是基于 multer的1.3.0版本，express的4.13.4版本进行操作的，其中<strong>index.js</strong>是路由文件，用来处理文件上传请求，<strong>form.ejs</strong>是前端页面，用来上传文件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save multer</span><br></pre></td></tr></table></figure>

<h2 id="修改index-js"><a href="#修改index-js" class="headerlink" title="修改index.js"></a>修改index.js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var multer  &#x3D; require(&#39;multer&#39;)</span><br><span class="line">var upload &#x3D; multer(&#123; dest: &#39;upload&#x2F;&#39; &#125;);&#x2F;&#x2F;dest 是上传的文件所在的目录,可以自定义</span><br></pre></td></tr></table></figure>

<h2 id="上传单个文件"><a href="#上传单个文件" class="headerlink" title="上传单个文件"></a>上传单个文件</h2><p>&emsp;&emsp;<strong>.single(fieldname)：</strong>接受一个名称的文件fieldname。单个文件将存储在req.file。</p>
<h3 id="form-ejs"><a href="#form-ejs" class="headerlink" title="form.ejs"></a>form.ejs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;h2&gt;单个文件上传&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot;  name&#x3D;&quot;logo&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.post(&#39;&#x2F;upload&#39;, upload.single(&#39;logo&#39;), function(req, res, next)&#123;</span><br><span class="line">&#x2F;&#x2F;logo为图片的name属性</span><br><span class="line">      res.redirect(&#39;&#x2F;form&#39;);</span><br><span class="line">      console.log(req.file.filename); &#x2F;&#x2F;获取文件的filename值，其他属性类似</span><br><span class="line">      console.log(&#39;单个文件上传&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="上传多个相同name值的文件"><a href="#上传多个相同name值的文件" class="headerlink" title="上传多个相同name值的文件"></a>上传多个相同name值的文件</h2><p>&emsp;&emsp;<strong>.array(fieldname[, maxCount])：</strong>接受一系列的文件，所有的名称fieldname。如果多于maxCount上传文件，可以选择是错误输出。文件数组将存储在 req.files。</p>
<h3 id="form-ejs-1"><a href="#form-ejs-1" class="headerlink" title="form.ejs"></a>form.ejs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;h2&gt;多个文件上传&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;logo&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;logo&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.post(&#39;&#x2F;upload&#39;, upload.array(&#39;logo&#39;, 2), function(req, res, next)&#123;</span><br><span class="line">    res.redirect(&#39;&#x2F;form&#39;);</span><br><span class="line">    console.log(rreq.files[0].filename); &#x2F;&#x2F;获取文件的filename值，其他属性类似</span><br><span class="line">    console.log(&#39;多个文件上传&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="上传多个不同name值的文件"><a href="#上传多个不同name值的文件" class="headerlink" title="上传多个不同name值的文件"></a>上传多个不同name值的文件</h2><p>&emsp;&emsp;<strong>.fields(fields)：</strong>接受指定的文件混合fields。具有文件数组的对象将被存储req.files。fields应该是一个数组的对象name和可选的maxCount。</p>
<h3 id="form-ejs-2"><a href="#form-ejs-2" class="headerlink" title="form.ejs"></a>form.ejs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;h2&gt;多个不同name值文件上传&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file1&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file2&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file3&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file4&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file5&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="index-js-2"><a href="#index-js-2" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.post(&#39;&#x2F;upload&#39;, upload.fields([</span><br><span class="line">    &#123;name: &#39;file1&#39;&#125;,</span><br><span class="line">    &#123;name: &#39;file2&#39;&#125;,</span><br><span class="line">    &#123;name: &#39;file3&#39;&#125;,</span><br><span class="line">    &#123;name: &#39;file4&#39;&#125;,</span><br><span class="line">    &#123;name: &#39;file5&#39;&#125;</span><br><span class="line">]), function(req, res, next)&#123;</span><br><span class="line">     for(var i in req.files)&#123;</span><br><span class="line">        console.log(req.files[i]);&#x2F;&#x2F;输出每个文件的信息</span><br><span class="line">        var a&#x3D;req.files[i];</span><br><span class="line">        console.log(a[0].filename);&#x2F;&#x2F;获取文件的filename值，其他属性类似</span><br><span class="line">    &#125;</span><br><span class="line">    res.redirect(&#39;&#x2F;form&#39;);</span><br><span class="line">    &#x2F;&#x2F; console.log(&#39;多个不同name值文件&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每个文件对象包括以下信息:</p>
<ul>
<li>fieldname: ‘file5’,//在form表单中指定的name属性值</li>
<li>originalname: ‘good5.jpg’,//原始文件名</li>
<li>encoding: ‘7bit’,//文件的编码类型</li>
<li>mimetype: ‘image/jpeg’, //多媒体类型</li>
<li>destination: ‘upload/‘, //文件已被保存到的文件夹(ben)</li>
<li>filename: ‘7df920656f2aea54d6f62f51f58db037’, //保存在本地的文件名(保存后的名称)</li>
<li>path: ‘upload\7df920656f2aea54d6f62f51f58db037’,//文件保存的完整路径</li>
<li>size: 88400 //文件大小，单位b</li>
</ul>
<h2 id="自定义文件名（filename）和文件保存路径"><a href="#自定义文件名（filename）和文件保存路径" class="headerlink" title="自定义文件名（filename）和文件保存路径"></a>自定义文件名（filename）和文件保存路径</h2><p>&emsp;&emsp;multer 提供了 <strong>storage</strong> 这个参数来对资源保存的路径、文件名进行自定义的设置。<br>将<strong>index.js</strong>文件中的<code>var upload = multer(&#123; dest: &#39;upload/&#39; &#125;);</code><br>替换成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var storage &#x3D; multer.diskStorage(&#123;</span><br><span class="line">  destination: function (req, file, cb) &#123;</span><br><span class="line">    cb(null, &#39;.&#x2F;files&#39;);  &#x2F;&#x2F;保存的路径，备注：需要自己创建</span><br><span class="line">  &#125;,</span><br><span class="line">  filename: function (req, file, cb) &#123;</span><br><span class="line">    cb(null, file.originalname);&#x2F;&#x2F;文件名，这里设置成和原始名字一样</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var upload &#x3D; multer(&#123; storage: storage &#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码的执行结果：所有上传的文件都会保存到files文件夹中，且名字都和原始名字一样。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>&emsp;&emsp;multer官方文档：<a href="https://github.com/expressjs/multer">https://github.com/expressjs/multer</a></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>multer</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的PHP+MySql实现动态页面</title>
    <url>/2016/07/27/%E7%AE%80%E5%8D%95%E7%9A%84PHP-MySql%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>虽说自己学的是前端，但是关于前后端的一些交互还是有必要做简单的了解的。这两天学会了简单的PHP加上MySql数据库来实现动态页面，在WAMP的集成环境下设计了一个简单的注册页面，并将注册信息通过后端传送到数据库。</p>
<ol>
<li><p>首先创建好数据库，在WAMP的环境下，建立数据库“register”，并创建具有两个字段的“message”表，存放用户名(username)及密码(password)。当有用户注册填写相关信息时，所填信息会被保存到该数据库中。</p>
</li>
<li><p>首先创建”register.php”文件，在里面编写相关的前端代码。创建两个文本框分别为用户的姓名输入框和密码输入框，再加一个注册按钮，为注册按钮添加调用ajax的相关语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oBtn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> url=<span class="string">&#x27;register_post.php?act=add&amp;username=&#x27;</span>+oTxt1.value+<span class="string">&#x27;&amp;password=&#x27;</span>+oTxt2.value;</span><br><span class="line">ajax(url, <span class="function"><span class="keyword">function</span> (<span class="params">str</span>)</span>&#123;          </span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建”register_post.php”文件，在里面编写与数据库连接的代码以及数据库的执行操作语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">switch($_GET[&#39;act&#39;])</span><br><span class="line">&#123;</span><br><span class="line"> case &#39;add&#39;:</span><br><span class="line">  $username&#x3D;$_GET[&#39;username&#39;];&#x2F;&#x2F;接收前端上传的数据</span><br><span class="line">  $password&#x3D;$_GET[&#39;password&#39;];</span><br><span class="line">  $sql&#x3D;&quot;INSERT INTO message (username, password) VALUES(&#39;&#123;$username&#125;&#39;, &#39;&#123;$password&#125;&#39;)&quot;;</span><br><span class="line">  mysql_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;&#39;);</span><br><span class="line">  mysql_select_db(&#39;register&#39;);</span><br><span class="line">  mysql_query($sql);</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行”register.php”文件，输入用户名和密码，点击注册按钮，即可发现数据库多了所填写的用户名和密码字段，到此，一个小的动态注册页面完成。这里只是通过简单的做个小例子来让自己明白前后端的一些交互方式，并不做深入的学习。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>表格的排序和搜索</title>
    <url>/2016/07/25/%E8%A1%A8%E6%A0%BC%E7%9A%84%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>这两天学习了DOM的高级操作，主要是以对表格的一些排序和搜索处理为例子来进行学习的。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>表格的排序主要分为三个步骤:转换————排序————插入。<br>第一步，转换成数组。只有将获得的对象元素转换成数组才能进行大小的比较。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;oTab.tBodies[<span class="number">0</span>].rows.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i]=oTab.tBodies[<span class="number">0</span>].rows[i];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>第二步，数组排序。这里是升序排列的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">tr1, tr2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">parseInt</span>(tr1.cells[<span class="number">0</span>].innerHTML)-<span class="built_in">parseInt</span>(tr2.cells[<span class="number">0</span>].innerHTML);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>第三步，重新插入。将排列好的数组插入到表格中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          oTab.tBodies[<span class="number">0</span>].appendChild(arr[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码已经能实现将表格进行升序排列，若还想实现降序排列需要如下的改进。先创建一个布尔变量，当值为true时，进行升序排列，否则为降序排列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bAsc=<span class="literal">true</span>;<span class="comment">//判断是否升序排列</span></span><br></pre></td></tr></table></figure>
<p>然后，添加降序排列代码，就可以通过if-else语句判断是降序排列还是升序排列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span>(tr2.cells[<span class="number">0</span>].innerHTML)-<span class="built_in">parseInt</span>(tr1.cells[<span class="number">0</span>].innerHTML);  </span><br></pre></td></tr></table></figure>
<p>最后，就是添加以下一行代码，就可以实现通过按钮的点击来交替实现两种排列方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bAsc=!bAsc;</span><br></pre></td></tr></table></figure>

<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>表格的搜索是通过将文本框的字符串与表格指定位置的字符串进行比较，如果是相等的，则将那行的背景颜色变为黄色(也可以是其他颜色）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;oTab.tBodies[<span class="number">0</span>].rows.length;i++)</span><br><span class="line">&#123;   <span class="comment">//全部化成小写(大写也行)再比较，实现不区分大小写</span></span><br><span class="line">  <span class="keyword">var</span> sValueInTab=oTab.tBodies[<span class="number">0</span>].rows[i].cells[<span class="number">1</span>].innerHTML.toLowerCase();</span><br><span class="line">  <span class="keyword">var</span> sValueInTxt=oTxt.value.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span>(sValueInTab==sValueInTxt)</span><br><span class="line">    &#123;</span><br><span class="line">       oTab.tBodies[<span class="number">0</span>].rows[i].style.background=<span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">       oTab.tBodies[<span class="number">0</span>].rows[i].style.background=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       &#125;   &#125;   </span><br></pre></td></tr></table></figure>
<p>但是如果想实现多关键词搜索，还需要做以下的改进，先将文本框的关键字用空格作为分割的标记对输入的关键字进行分割，然后利用search()方法去搜索，看看表格的字符串与文本框的字符串是否有一样的，如果搜索不到一样的字符串，则返回-1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=sValueInTxt.split(<span class="string">&#x27; &#x27;</span>);<span class="comment">//将关键字分割</span></span><br><span class="line"><span class="keyword">var</span> bFound=<span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;arr.length;j++)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span>(sValueInTab.search(arr[j])!=-<span class="number">1</span>)</span><br><span class="line">   &#123;   <span class="comment">//搜索不到</span></span><br><span class="line">       bFound=<span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;      &#125;</span><br><span class="line">  <span class="keyword">if</span>(bFound)</span><br><span class="line">   &#123;</span><br><span class="line">     oTab.tBodies[<span class="number">0</span>].rows[i].style.background=<span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">    oTab.tBodies[<span class="number">0</span>].rows[i].style.background=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">           &#125;     </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>DOM操作———表格</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Next主题主页空白</title>
    <url>/2016/11/19/%E8%A7%A3%E5%86%B3Next%E4%B8%BB%E9%A2%98%E4%B8%BB%E9%A1%B5%E7%A9%BA%E7%99%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;最近一个月都没有发布文章到hexo博客上，今天发布一篇学习笔记到博客，本地测试正常，但是部署到github上，再进行测试却发现博客全部空白了。网上找了好多资料，终于找到解决方法了。</p>
<h2 id="问题出现原因"><a href="#问题出现原因" class="headerlink" title="问题出现原因"></a>问题出现原因</h2><p>&emsp;&emsp;由于 GitHub 升级 gitpage，Next主题下面下<code>source/vendors</code>目录的访问受限。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>将<code>source/vendors</code>目录修改成<code>source/lib</code> （不一定是lib，也可以是其他的名称）。</li>
<li>修改下Next主题配置文件<code>_config.yml</code>， 将<code>_internal: vendors</code> 改成所修改的名字<code>_internal: lib</code>（其他名称的只需将lib替换即可）。</li>
<li>修改 next 底下所有引用<code>source/vendors</code>路径为<code>source/lib</code>：<br> 1.Hexo\themes\next.bowerrc<br> 2.Hexo\themes\next.gitignore<br> 3.Hexo\themes\next.javascript_ignore<br> 4.Hexo\themes\next\bower.json </li>
<li>最后刷新下，然后<code>hexo g</code>，再<code>hexo d</code>，打开博客，发现内容正常显示。</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>走进canvas</title>
    <url>/2017/04/04/%E8%B5%B0%E8%BF%9Bcanvas/</url>
    <content><![CDATA[<h2 id="canvas是什么？"><a href="#canvas是什么？" class="headerlink" title="canvas是什么？"></a>canvas是什么？</h2><p>&emsp;&emsp;<code>&lt;canvas&gt;</code>是一个可以使用脚本在其中绘制图形的HTML 元素。什么意思呢？就是canvas元素本身并不绘制图形，它只是相当于一张空画布。如果想在canvas上绘制图形，则必须使用 JavaScript脚本来进行绘制。</p>
<h2 id="canvas的基本用法"><a href="#canvas的基本用法" class="headerlink" title="canvas的基本用法"></a>canvas的基本用法</h2><h3 id="定义-canvas-元素"><a href="#定义-canvas-元素" class="headerlink" title="定义 canvas 元素"></a>定义 canvas 元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;canvas&quot; width&#x3D;&quot;1920&quot; height&#x3D;&quot;1200&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;<code>&lt;canvas&gt;</code>标签只有两个属性—— <code>width</code>和<code>height</code>，这两个属性都是可选的，当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。要注意一点，因为<code>&lt;canvas&gt;</code>是<strong>双标签</strong>，所以结束标签<code>&lt;/canvas&gt;</code>一定<strong>不可以省略</strong>。</p>
<h3 id="获取canvas-元素对应的-DOM-对象"><a href="#获取canvas-元素对应的-DOM-对象" class="headerlink" title="获取canvas 元素对应的 DOM 对象"></a>获取canvas 元素对应的 DOM 对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;得到DOM对象</span><br><span class="line">var canvas &#x3D; document.getElementById(&#39;canvas&#39;);</span><br></pre></td></tr></table></figure>
<h3 id="调用-canvas-对象的-getContext-方法"><a href="#调用-canvas-对象的-getContext-方法" class="headerlink" title="调用 canvas 对象的 getContext()方法"></a>调用 canvas 对象的 getContext()方法</h3><p>&emsp;&emsp;&emsp;&emsp;这个方法是用来获得渲染上下文和绘画功能。该方法会返回一个 <code>canvasRenderingContext2D</code>对象，该对象可以绘制图形。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ctx &#x3D; canvas.getContext(&#39;2d&#39;);</span><br></pre></td></tr></table></figure>
<h3 id="调用canvas的方法进行绘图"><a href="#调用canvas的方法进行绘图" class="headerlink" title="调用canvas的方法进行绘图"></a>调用canvas的方法进行绘图</h3><p>&emsp;&emsp;&emsp;&emsp;这些后面会提到。</p>
<h2 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h2><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><ul>
<li><strong>rect(x, y, width, height)</strong></li>
</ul>
<p>&emsp;&emsp;&emsp;&emsp;绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。没有填充的话，不会显示。</p>
<ul>
<li><strong>fillRect(x, y, width, height)</strong></li>
</ul>
<p>&emsp;&emsp;&emsp;&emsp;绘制一个左上角坐标为（x,y），宽高为width以及height并填充的矩形，默认填充颜色为黑色。</p>
<ul>
<li><strong>strokeRect(x, y, width, height)</strong></li>
</ul>
<p>&emsp;&emsp;&emsp;&emsp;绘制一个左上角坐标为（x,y），宽高为width以及height的矩形边框，默认边框颜色为黑色。</p>
<ul>
<li><strong>clearRect(x, y, width, height)</strong><br>&emsp;&emsp;清除指定矩形区域，让清除部分完全透明。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;边长为100px的黑色正方形</span><br><span class="line">ctx.fillRect(25,25,100,100); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从正方形的中心开始擦除了一个60*60px的正方形</span><br><span class="line">ctx.clearRect(45,45,60,60);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在清除区域内生成一个50*50的正方形边框  </span><br><span class="line">ctx.strokeRect(50,50,50,50);  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><p>&emsp;&emsp;图形的基本元素是路径。一个路径，甚至一个子路径，都是闭合的。以下为常用的几个方法，很多图形其实是通过绘制路径而绘制出来的。</p>
<ul>
<li><strong>beginPath()</strong><br>&emsp;&emsp;新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</li>
<li><strong>closePath()</strong><br>&emsp;&emsp;闭合路径之后图形绘制命令又重新指向到上下文中。闭合路径closePath(),不是必需的，比如路径使用填充（filled）时，路径会自动闭合，可以不用closePath()；但是如果使用描边（stroked）则不会闭合路径。</li>
<li><strong>stroke()</strong><br>&emsp;&emsp;通过线条来绘制图形轮廓。</li>
<li><strong>fill()</strong><br>&emsp;&emsp;通过填充路径的内容区域生成实心的图形。</li>
<li><strong>moveTo(x, y)</strong><br>&emsp;&emsp;把 canvas 的当前路径的结束点移动到 x, y 对应的点。通常会使用moveTo()函数设置起点，也可以绘制一些不连续的路径。</li>
</ul>
<h4 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h4><p>&emsp;&emsp;**lineTo(x, y)**：绘制一条从当前位置到指定x以及y位置的直线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(125,125);</span><br><span class="line">ctx.lineTo(125,45);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<h4 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h4><p>&emsp;&emsp;绘制三角形其实就是绘制好闭合路径，然后对其进行填充或者描边的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 填充三角形</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(25,25);</span><br><span class="line">ctx.lineTo(105,25);</span><br><span class="line">ctx.lineTo(25,105);</span><br><span class="line">ctx.fill();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 描边三角形</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(125,125);</span><br><span class="line">ctx.lineTo(125,45);</span><br><span class="line">ctx.lineTo(45,125);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<h4 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h4><ul>
<li><strong>arc(x, y, radius, startAngle, endAngle, anticlockwise)</strong><br>&emsp;&emsp;画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为false，顺时针）来生成。</li>
<li><strong>arcTo(x1, y1, x2, y2, radius)</strong><br>&emsp;&emsp;根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点(x1, y1)和(x2, y2)。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var canvas &#x3D; document.getElementById(&quot;canvas&quot;);</span><br><span class="line">var ctx &#x3D; canvas.getContext(&quot;2d&quot;);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(75, 75, 50, 0, 2 * Math.PI);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>
<h4 id="绘制贝塞尔曲线"><a href="#绘制贝塞尔曲线" class="headerlink" title="绘制贝塞尔曲线"></a>绘制贝塞尔曲线</h4></li>
<li><strong>quadraticCurveTo(cp1x, cp1y, x, y)</strong><br>&emsp;&emsp;绘制贝塞尔曲线，cp1x,cp1y为控制点，x,y为结束点。</li>
<li><strong>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</strong><br>&emsp;&emsp;绘制二次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x，y为结束点。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制一个对话气泡</span><br><span class="line">var canvas &#x3D; document.getElementById(&#39;canvas&#39;);</span><br><span class="line">var ctx &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(75,25);</span><br><span class="line">ctx.quadraticCurveTo(25,25,25,62.5);</span><br><span class="line">ctx.quadraticCurveTo(25,100,50,100);</span><br><span class="line">ctx.quadraticCurveTo(50,120,30,125);</span><br><span class="line">ctx.quadraticCurveTo(60,120,65,100);</span><br><span class="line">ctx.quadraticCurveTo(125,100,125,62.5);</span><br><span class="line">ctx.quadraticCurveTo(125,25,75,25);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制一颗爱心</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(75,40);</span><br><span class="line">ctx.bezierCurveTo(75,37,70,25,50,25);</span><br><span class="line">ctx.bezierCurveTo(20,25,20,62.5,20,62.5);</span><br><span class="line">ctx.bezierCurveTo(20,80,40,102,75,120);</span><br><span class="line">ctx.bezierCurveTo(110,102,130,80,130,62.5);</span><br><span class="line">ctx.bezierCurveTo(130,62.5,130,25,100,25);</span><br><span class="line">ctx.bezierCurveTo(85,25,75,37,75,40);</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h2><ul>
<li><strong>fillStyle = color</strong>：设置图形的填充颜色。</li>
<li><strong>strokeStyle = color</strong>：设置图形轮廓的颜色。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle &#x3D; &quot;blue&quot;;</span><br><span class="line">ctx.fillRect(10, 10, 100, 100);</span><br><span class="line">ctx.strokeStyle &#x3D; &quot;red&quot;;</span><br><span class="line">ctx.strokeRect(10, 10, 100, 100);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><ul>
<li><strong>fillText(text, x, y [, maxWidth])</strong><br>&emsp;&emsp;在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的。</li>
<li><strong>strokeText(text, x, y [, maxWidth])</strong><br>&emsp;&emsp;在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;文字是填充的</span><br><span class="line">ctx.fillText(&quot;Hello world&quot;, 10, 50); </span><br><span class="line">&#x2F;&#x2F;文字是边框的</span><br><span class="line">ctx.strokeText(&quot;Hello world&quot;, 10, 50); </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h2><p><strong>drawImage(image, x, y)</strong><br>&emsp;&emsp;其中 image 是 image 或者 canvas 对象，x和y是其在目标canvas里的起始坐标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var img &#x3D; new Image();   &#x2F;&#x2F; 创建一个img元素</span><br><span class="line">img.onload &#x3D; function()&#123;</span><br><span class="line">&#x2F;&#x2F; 执行drawImage语句</span><br><span class="line"> ctx.drawImage(img, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">img.src &#x3D; &#39;a.png&#39;; &#x2F;&#x2F; 设置图片源地址</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;若调用 drawImage 方法时，图片还没装载完，那么什么都不会发生。所以应该用load时间来保证不会在加载完毕之前使用这个图片。</p>
<h2 id="状态的保存和恢复"><a href="#状态的保存和恢复" class="headerlink" title="状态的保存和恢复"></a>状态的保存和恢复</h2><p>&emsp;&emsp;<strong>save()**和</strong>restore()<strong>方法是用来保存和恢复 canvas 状态的，都没有参数，这两个是相互匹配出现的。当save()方法被调用后，当前的状态就会被推送到栈中保存；当 restore 方法被调用后，上一个保存的状态就从栈中弹出，所有设定都会恢复。那么</strong>为什么需要保存canvas状态呢**？<br>&emsp;&emsp;当我们对画布进行旋转，缩放，平移等操作的时候，我们只想对特定的元素进行操作，比如图片，一个矩形等，但是当你用canvas的方法来进行这些操作的时候，其实是对整个画布进行了操作，那么之后在画布上的元素都会受到影响，所以在操作之前调用canvas.save()来保存画布当前的状态，当操作之后取出之前保存过的状态，这样就不会对其他的元素进行影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.save(); &#x2F;&#x2F; 保存默认的状态</span><br><span class="line">ctx.fillStyle &#x3D; &quot;green&quot;;</span><br><span class="line">ctx.fillRect(10, 10, 100, 100);</span><br><span class="line">ctx.restore(); &#x2F;&#x2F; 还原到上次保存的默认状态</span><br><span class="line">ctx.fillRect(150, 75, 100, 100);</span><br></pre></td></tr></table></figure>

<h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p><strong>translate(x, y)</strong><br>&emsp;&emsp;translate方法接受两个参数。x 是左右偏移量，y 是上下偏移量。对于这个方法，很多人会有个误解，认为translate（x，y）是把点（x，y）作为新的坐标原点。其实并不是这样的。Translate(x,y)表示原来的原点分别在x轴和y轴偏移多远的距离，然后以偏移后的位置作为坐标原点。假如原点落在（1，1），那么translate（10，10）就是在原点（1，1）基础上分别在x轴、y轴移动10，则原点变为（11,11）。</p>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><strong>rotate(angle)</strong><br>&emsp;&emsp;这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。要注意的是这里指的是弧度，弧度和度的概念是不一样的，它们之间的关系可以用一个计算公式来表示，<code>弧度＝度 × π/180</code>。</p>
<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p><strong>scale(x, y)</strong><br>&emsp;&emsp;scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。比如设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>画一帧动画的步骤：<br>（1）<strong>清空 canvas</strong><br>&emsp;&emsp;除非接下来要画的内容会完全充满 canvas（如背景图），否则需要清空所有，可以用 clearRect()方法来清空。<br>（2）<strong>保存 canvas 状态</strong><br>&emsp;&emsp;如果要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，需要先保存一下。<br>（3）<strong>绘制动画图形</strong><br>&emsp;&emsp;这一步才是重绘动画帧。<br>（4）<strong>恢复 canvas 状态</strong><br>&emsp;&emsp;如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var car &#x3D; new Image();</span><br><span class="line">function init()&#123;</span><br><span class="line">  car.src &#x3D; &#39;car.png&#39;;</span><br><span class="line">  window.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line">function draw()&#123;</span><br><span class="line">      var ctx &#x3D; document.getElementById(&#39;canvas&#39;).getContext(&#39;2d&#39;);</span><br><span class="line">      ctx.save();</span><br><span class="line">      ctx.clearRect(0, 0, 1920, 1200); </span><br><span class="line">      ctx.scale(0.5, 0.5); </span><br><span class="line">      ctx.rotate(90);</span><br><span class="line">      ctx.drawImage(car, Math.floor(-car.width&#x2F;2), Math.floor(-car.height&#x2F;2));</span><br><span class="line">      ctx.restore();</span><br><span class="line">      window.requestAnimationFrame(draw);</span><br><span class="line">  &#125;</span><br><span class="line">$(document).ready(function() &#123;</span><br><span class="line">      init();      </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>requestAnimationFrame函数</strong>，传递一个callback参数，在下一个动画帧时，会调用callback。这个函数可以告诉浏览器希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。</p>
<h2 id="使用多层画布"><a href="#使用多层画布" class="headerlink" title="使用多层画布"></a>使用多层画布</h2><p>&emsp;&emsp;在画一个复杂的场景时，有些元素不断地改变或者移动，而其它的元素，如背景，永远不变。这个时候可以考虑用多个画布元素去创建不同层次来进行优化，将需要一直变动的元素和不变的元素分开放在不同层次的画布中，便于操作。这里要注意的是canvas<strong>不能嵌套，只能层叠</strong>。<br>&emsp;&emsp;多层的canvas可以通过设置定位来实现每一层都可独立移动而相互之间不影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用3个canvas</span><br><span class="line">&lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;canvas id&#x3D;&quot;canvas1&quot; width&#x3D;&quot;480&quot; height&#x3D;&quot;320&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">  &lt;canvas id&#x3D;&quot;canvas2&quot; width&#x3D;&quot;480&quot; height&#x3D;&quot;320&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">  &lt;canvas id&#x3D;&quot;canvas3&quot; width&#x3D;&quot;480&quot; height&#x3D;&quot;320&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line">  #container &#123;</span><br><span class="line">    width: 480px;</span><br><span class="line">    height: 320px;</span><br><span class="line">    position: relative;</span><br><span class="line">   &#125;</span><br><span class="line">  canvas &#123; position: absolute; &#125;</span><br><span class="line">  #canvas1 &#123; z-index: 3 &#125;</span><br><span class="line">  #canvas2 &#123; z-index: 2 &#125;</span><br><span class="line">  #canvas3 &#123; z-index: 1 &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2019/01/09/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h1><p>&emsp;&emsp;限制一个源加载的文档或脚本与来自另一个源的资源进行交互。要求源相同才能正常进行通信，即协议、域名、端口号（HTTP 协议的默认端口是 80）都完全一致。</p>
<h1 id="同源策略限制的内容及原因"><a href="#同源策略限制的内容及原因" class="headerlink" title="同源策略限制的内容及原因"></a>同源策略限制的内容及原因</h1><h2 id="限制不同源发请求"><a href="#限制不同源发请求" class="headerlink" title="限制不同源发请求"></a>限制不同源发请求</h2><p>&emsp;&emsp;不能向工作在不同源的的服务请求数据(client to server)。<br>&emsp;&emsp;<strong>原因：</strong>假设用户登陆了 a.com，同时打开了 b.com，如果没有任何限制，b.com 可以向 a.com 请求到任何信息，进而就可以在 b.com 向 a 发转账请求等。这里是限制了读 u，而没有限制写，因为如果连请求都发不出去了，也就无法做跨域资源共享了，无法读取返回结果，b 就无法继续下一步的操作，如获取转账请求的一些必要的验证信息。</p>
<h2 id="限制跨域的-DOM-读取"><a href="#限制跨域的-DOM-读取" class="headerlink" title="限制跨域的 DOM 读取"></a>限制跨域的 DOM 读取</h2><p>&emsp;&emsp;无法获取不同源的 document/cookie 等 BOM 和 DOM，可以说任何有关另外一个源的信息都无法得到 (client to client)。<br>&emsp;&emsp;<strong>原因：</strong>如果不限制的话，那么很容易就可以伪装其它的网站，如套一个 iframe 或者通过 window.open 的方法，从而得到用户的操作和输入，如账户、密码。<br>&emsp;&emsp;<strong>小技巧：</strong>添加这个 http 头—“X-Frame-Options: SAMEORIGIN”，可以限制别人把你的网站套成它的 iframe。</p>
<h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><p>&emsp;&emsp;跨域是由浏览器的同源策略引起的，只有源(协议、域名、端口号)相同才能正常进行通信，域名、端口、协议任一不同，都是跨域。跨域只存在于浏览器端，不存在于安卓/ios/Node.js/python/ java 等其它环境。以下列举几种情况都属于跨域：</p>
<ol>
<li>同一域名，不同协议</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.a.com&#x2F;b.js ---&gt; http:&#x2F;&#x2F;www.a.com&#x2F;a.js</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>域名和域名对应 ip</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;70.32.92.74&#x2F;b.js  ---&gt; http:&#x2F;&#x2F;www.a.com&#x2F;a.js</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同一域名，不同端口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.a.com:8000&#x2F;a.js  ---&gt; http:&#x2F;&#x2F;www.a.com&#x2F;b.js</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>不同域名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cnblogs.com&#x2F;a.js  ---&gt; http:&#x2F;&#x2F;www.a.com&#x2F;b.js</span><br></pre></td></tr></table></figure>

<h1 id="跨域的解决"><a href="#跨域的解决" class="headerlink" title="跨域的解决"></a>跨域的解决</h1>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>一个基于Node.js的web 应用</title>
    <url>/2016/09/08/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8ENode.js%E7%9A%84web%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Node.js是一个JavaScript运行环境，允许在后端（脱离浏览器环境）运行JavaScript代码。那么在后台中又是如何运行JavaScript代码的呢？Node.js使用了 Google 的V8 虚拟机（Google 的Chrome 浏览器使用的JavaScript 执行环境）来解释和执行 JavaScript代码。<br>初识Node.js，通过完成一个完整的基于 Node.js 的 web 应用来让自己对Node.js有个初步的认识，下面就是完成该应用的具体过程。</p>
<h2 id="应用目标"><a href="#应用目标" class="headerlink" title="应用目标"></a>应用目标</h2><ol>
<li><p>用户可以通过浏览器使用我们的应用。</p>
</li>
<li><p>当用户请求 <a href="http://domain/start">http://domain/start</a> 时，可以看到一个欢迎页面，<br>页面上有一个文本框和提交按钮。</p>
</li>
<li><p>用户可以在文本框输入相应的内容并提交表单，随后文本框的内容将被上传到<br><a href="http://domain/upload%EF%BC%8C">http://domain/upload，</a> 该页面完成上传后会把文本框内容显示在页面上。</p>
</li>
</ol>
<h2 id="应用不同模块分析"><a href="#应用不同模块分析" class="headerlink" title="应用不同模块分析"></a>应用不同模块分析</h2><ol>
<li><p>需要一个 <strong>HTTP 服务器</strong>，用于提供 Web 页面。</p>
</li>
<li><p>需要一个 <strong>路由</strong>，用于把请求对应到请求处理程序（对于不同的请求，服务器需要给予不同的响应）。</p>
</li>
<li><p>需要一个最终的 <strong>请求处理程序</strong>，用于处理被服务器接收并通过路由传递之后的请求。</p>
</li>
<li><p>需要 <strong>请求数据处理功能</strong>。路由应该能处理 POST 数据，并且把数据封装成更友好的格式传递给请求处理入程序。</p>
</li>
<li><p>需要一些 <strong>视图逻辑</strong>供请求处理程序使用，用于将内容发送给用户的浏览器，显示给用户。</p>
</li>
</ol>
<h2 id="构建应用的模块"><a href="#构建应用的模块" class="headerlink" title="构建应用的模块"></a>构建应用的模块</h2><h3 id="构建HTTP-服务器"><a href="#构建HTTP-服务器" class="headerlink" title="构建HTTP 服务器"></a>构建HTTP 服务器</h3><p>创建一个叫server.js 的文件，并写入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="comment">//请求Node.js 自带的 http 模块，并且把它赋值给 http 变量</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request,response</span>)</span>&#123;</span><br><span class="line"><span class="comment">//createServer为http 模块提供的函数</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    response.end();</span><br><span class="line"> &#125;).listen(<span class="number">8888</span>); </span><br><span class="line"><span class="comment">// listen方法里的数值参数，指定这个 HTTP 服务器监听的端口号(这里为8888)</span></span><br></pre></td></tr></table></figure>
<p>输入node.js命令“node server.js”执行文件,打开浏览器<a href="http://localhost:8888/%EF%BC%8C">http://localhost:8888/，</a> 可以看到一个写着“Hello World”的网页。</p>
<h4 id="函数传递是如何让-HTTP-服务器工作的"><a href="#函数传递是如何让-HTTP-服务器工作的" class="headerlink" title="函数传递是如何让 HTTP 服务器工作的"></a>函数传递是如何让 HTTP 服务器工作的</h4><p>通过函数传递的方法让HTTP 服务器工作，我们可以将上述的代码修改成如下的，当然二者的实现结果是相同的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>将修改后的代码与之前未修改的代码进行比较，可以发现修改前我们向 createServer 函数传递了的是一个匿名函数；而经过修改后，我们首先定义一个“onRequest”函数，然后再将该函数以参数的形式传递给createServer 函数。</p>
<h4 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h4><p>函数 onRequest() 里面的内容就是服务器处理请求的内容。当onRequest() 函数被触发的时候，有两个参数被传入：request 和response。这2个都是对象，通过使用它们的方法可以处理 HTTP 请求的细节，并且响应请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表示，当收到请求时，使用 response.writeHead() 函数发送一个 HTTP 状态 200 和 HTTP 头的内容类型；使用 response.write() 函数在 HTTP 相应主体中发送文本 “HelloWorld”；最后调用 response.end() 完成响应。</p>
<h4 id="调用HTTP-服务器模块"><a href="#调用HTTP-服务器模块" class="headerlink" title="调用HTTP 服务器模块"></a>调用HTTP 服务器模块</h4><p>通常我们会有一个叫 index.js 的文件去调用应用的其他模块来引导和启动应用。所以要让server.js能被index.js 主文件(还没创建)使用，应该先把 server.js 变成一个真正的 Node.js 模块。把某段代码变成模块只要将希望提供其功能的部分导出到请求这个模块的脚本即可。</p>
<p> （1） 修改server.js的代码，将server.js中的服务器脚本放到一个叫做 start 的函数里，再导出这个函数，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request received.&quot;</span>);</span><br><span class="line">    response.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    response.end();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Server has started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.start=start;  <span class="comment">//导出</span></span><br></pre></td></tr></table></figure>

<p> （2） 创建index.js主文件，然后通过index.js来启动HTTP服务器。index.js主文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server=<span class="built_in">require</span>(<span class="string">&quot;./server&quot;</span>);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
<h4 id="执行应用"><a href="#执行应用" class="headerlink" title="执行应用"></a>执行应用</h4><p>输入node.js命令“node index.js”执行文件，在命令编辑框中会显示“Server has started”；打开浏览器<a href="http://localhost:8888/">http://localhost:8888/</a> ，同样可以看到一个写着“Hello World”的网页，此时命令编辑框中会再显示“Request received.”。</p>
<h3 id="构建路由模块"><a href="#构建路由模块" class="headerlink" title="构建路由模块"></a>构建路由模块</h3><p>编写一个路由模块——即创建一个叫server.js 的文件，并写入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">pathname</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;About to route a request for&quot;</span>+pathname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.route=route;</span><br></pre></td></tr></table></figure>
<h4 id="修改srever-js文件"><a href="#修改srever-js文件" class="headerlink" title="修改srever.js文件"></a>修改srever.js文件</h4><p>为了获取浏览器请求的URL路径，需要给 onRequest()函数加上一些逻辑。然后我们就可以通过获取的URL路径区别POST请求和GET请求了。同时，我们也需要将路由函数作为参数传递过去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> url=<span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route</span>)</span>&#123; <span class="comment">//将路由参数作为参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname=url.parse(request.url).pathname;  <span class="comment">//获取URL路径</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request for&quot;</span>+pathname+<span class="string">&quot;received&quot;</span>);</span><br><span class="line"></span><br><span class="line">    route(pathname);</span><br><span class="line"></span><br><span class="line">    response.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Server has started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.start=start;</span><br></pre></td></tr></table></figure>
<h4 id="修改index-js文件"><a href="#修改index-js文件" class="headerlink" title="修改index.js文件"></a>修改index.js文件</h4><p>通过修改index.js，使得路由函数可以被注入到服务器中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server=<span class="built_in">require</span>(<span class="string">&quot;./server&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> router=<span class="built_in">require</span>(<span class="string">&quot;./router&quot;</span>);</span><br><span class="line"></span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure>
<h4 id="执行应用-1"><a href="#执行应用-1" class="headerlink" title="执行应用"></a>执行应用</h4><p>输入node.js命令“node index.js”执行文件，然后打开浏览器 <a href="http://localhost:8888/">http://localhost:8888/</a>   ， 同样可以看到一个写着“Hello World”的网页，此时命令编辑框中会显示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Server has started</span><br><span class="line">Request <span class="keyword">for</span>/received</span><br><span class="line">About to route a request <span class="keyword">for</span>/</span><br><span class="line">Request <span class="keyword">for</span>/favicon.icoreceived</span><br><span class="line">About to route a request <span class="keyword">for</span>/favicon.ico</span><br></pre></td></tr></table></figure>
<p>以上信息表明HTTP 服务器已经在使用路由模块了，并且会将请求的路径传递给路由。</p>
<h3 id="构建请求处理程序"><a href="#构建请求处理程序" class="headerlink" title="构建请求处理程序"></a>构建请求处理程序</h3><p>针对被服务器接收并通过路由传递过来的不同请求，我们需要有不同的处理方式，因此需要请求处理程序来分别进行处理。创建一个“requestHandlers.js”文件，添加2个请求处理程序，并分别为其添加一个函数，然后再将这些函数作为模块的方法导出。requestHandlers.js中代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request handle &#x27;start&#x27; was called.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request handle &#x27;upload&#x27; was called.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.start=start;</span><br><span class="line"><span class="built_in">exports</span>.upload=upload;</span><br></pre></td></tr></table></figure>
<h4 id="修改index-js文件-1"><a href="#修改index-js文件-1" class="headerlink" title="修改index.js文件"></a>修改index.js文件</h4><p>将一系列请求处理程序通过对象来传递。先将对象引入到index.js中，对index.js进行修改，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server=<span class="built_in">require</span>(<span class="string">&quot;./server&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> router=<span class="built_in">require</span>(<span class="string">&quot;./router&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> requestHandlers=<span class="built_in">require</span>(<span class="string">&quot;./requestHandlers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handle=&#123;&#125;</span><br><span class="line">handle[<span class="string">&quot;/&quot;</span>]=requestHandlers.start;  <span class="comment">//&quot;/&quot;的请求由start处理程序处理</span></span><br><span class="line">handle[<span class="string">&quot;/start&quot;</span>]=requestHandlers.start;  <span class="comment">//&quot;/start&quot;的请求由start处理程序处理</span></span><br><span class="line">handle[<span class="string">&quot;/upload&quot;</span>]=requestHandlers.upload;  <span class="comment">//&quot;/upload&quot;的请求由upload处理程序处理</span></span><br><span class="line"></span><br><span class="line">server.start(router.route,handle);</span><br></pre></td></tr></table></figure>
<h4 id="修改server-js文件"><a href="#修改server-js文件" class="headerlink" title="修改server.js文件"></a>修改server.js文件</h4><p>将对象传递给服务器，对server.js进行修改，如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> url=<span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route,handle</span>)</span>&#123; <span class="comment">//将handle 参数传给start()函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname=url.parse(request.url).pathname; <span class="comment">//获取URL路径</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request for&quot;</span>+pathname+<span class="string">&quot;received&quot;</span>);</span><br><span class="line"></span><br><span class="line">    route(handle,pathname); <span class="comment">//将handle 参数传给route()函数</span></span><br><span class="line"></span><br><span class="line">    response.writeHead(<span class="number">200</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Server has started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.start=start;</span><br></pre></td></tr></table></figure>
<h4 id="修改route-js文件"><a href="#修改route-js文件" class="headerlink" title="修改route.js文件"></a>修改route.js文件</h4><p>修改route.js文件，将handle 参数传给route()函数，修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle,pathname</span>)</span>&#123;<span class="comment">//将handle 参数传给route()函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;About to route a request for&quot;</span>+pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> handle[pathname]==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        handle[pathname]();  <span class="comment">//从传递的对象中获取请求处理函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;No request handle found for&quot;</span>+pathname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.route=route;</span><br></pre></td></tr></table></figure>
<p>通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。</p>
<h4 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h4><p>经过以上的处理，就可以把服务器、 路由和请求处理程序在一起了。启动应用程序并在浏览器中访问  <a href="http://localhost:8888/start">http://localhost:8888/start</a>   ，请求会由start处理程序处理，命令编辑框显示结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Server has started</span><br><span class="line">Request <span class="keyword">for</span>/startreceived</span><br><span class="line">About to route a request <span class="keyword">for</span>/start</span><br><span class="line">Request handle <span class="string">&#x27;start&#x27;</span> was called.</span><br><span class="line">Request <span class="keyword">for</span>/favicon.icoreceived</span><br><span class="line">About to route a request <span class="keyword">for</span>/favicon.ico</span><br><span class="line">No request handle found <span class="keyword">for</span>/favicon.ico</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问 <a href="http://localhost:8888，">http://localhost:8888，</a> 请求同样由start处理程序处理，命令编辑框显示结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Server has started</span><br><span class="line">Request <span class="keyword">for</span>/received</span><br><span class="line">About to route a request <span class="keyword">for</span>/</span><br><span class="line">Request handle <span class="string">&#x27;start&#x27;</span> was called.</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问<a href="http://localhost:8888/upload%EF%BC%8C">http://localhost:8888/upload，</a> 请求会由upload处理程序处理，命令编辑框显示结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Server has started</span><br><span class="line">Request <span class="keyword">for</span>/uploadreceived</span><br><span class="line">About to route a request <span class="keyword">for</span>/upload</span><br><span class="line">Request handle <span class="string">&#x27;upload&#x27;</span> was called.</span><br></pre></td></tr></table></figure>
<h3 id="让请求处理程序作出响应"><a href="#让请求处理程序作出响应" class="headerlink" title="让请求处理程序作出响应"></a>让请求处理程序作出响应</h3><p>采用将服务器“传递”给内容的方式，就是将 response 对象（从服务器的回调函数 onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。</p>
<h4 id="修改server-js文件-1"><a href="#修改server-js文件-1" class="headerlink" title="修改server.js文件"></a>修改server.js文件</h4><p>不再从 route()函数获取返回值，而是将 response 对象作为第三个参数传递给 route()函数；然后将 onRequest()处理程序中所有有关 response 的函数调用都移除，这部分工作会让route()函数来完成。对server.js进行修改，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> url=<span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route,handle</span>)</span>&#123; <span class="comment">//将handle 参数传给start()函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname=url.parse(request.url).pathname; <span class="comment">//获取URL路径</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request for&quot;</span>+pathname+<span class="string">&quot;received&quot;</span>);</span><br><span class="line"></span><br><span class="line">    route(handle,pathname,response); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Server has started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.start=start;</span><br></pre></td></tr></table></figure>
<h4 id="修改router-js文件"><a href="#修改router-js文件" class="headerlink" title="修改router.js文件"></a>修改router.js文件</h4><p>不再从请求处理程序中获取返回值，而是直接传递 response 对象。如果没有对应的请求处理器处理，我们就直接返回“404”错误。对router.js进行修改，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle,pathname,response</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;About to route a request for&quot;</span>+pathname);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">typeof</span> handle[pathname]==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">       handle[pathname](response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;No request handle found for&quot;</span>+pathname);</span><br><span class="line">       response.writeHead(<span class="number">404</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">       response.write(<span class="string">&quot;404 Not found&quot;</span>);</span><br><span class="line">       response.end();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">exports</span>.route=route;</span><br></pre></td></tr></table></figure>
<h4 id="修改-requestHandler-js文件"><a href="#修改-requestHandler-js文件" class="headerlink" title="修改 requestHandler.js文件"></a>修改 requestHandler.js文件</h4><p>处理程序函数需要接收 response 参数，为了对请求作出直接的响应。start 处理程序在 exec()的匿名函数中做请求响应的操作，而upload 处理程序仍然是回复“Hello World”，只是这次是使用response 对象而已。对requestHandler.js进行修改，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>).exec;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request handle &#x27;start&#x27; was called.&quot;</span>);</span><br><span class="line">    exec(<span class="string">&quot;ls -lah&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.write(stdout);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request handle &#x27;upload&#x27; was called.&quot;</span>);</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.write(<span class="string">&quot;Hello Upload&quot;</span>);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.start=start;</span><br><span class="line"><span class="built_in">exports</span>.upload=upload;</span><br></pre></td></tr></table></figure>
<h4 id="执行文件-1"><a href="#执行文件-1" class="headerlink" title="执行文件"></a>执行文件</h4><p>通过node.js命令执行文件，然后通过浏览器访问页面，可以发现一切正常工作，对于不同的请求，会由对应的处理程序去进行处理。</p>
<h3 id="上传内容功能"><a href="#上传内容功能" class="headerlink" title="上传内容功能"></a>上传内容功能</h3><p>通过显示一个文本区供用户输入内容，然后通过 POST 请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。</p>
<h4 id="构建一个表单"><a href="#构建一个表单" class="headerlink" title="构建一个表单"></a>构建一个表单</h4><p>用/start 请求处理程序生成带文本区的表单，在requestHandlers.js添加一些html代码。对requestHandlers.js 进行修改，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exec &#x3D; require(&quot;child_process&quot;).exec;</span><br><span class="line"></span><br><span class="line">function start(response)&#123;</span><br><span class="line">    console.log(&quot;Request handle &#39;start&#39; was called.&quot;);</span><br><span class="line">    </span><br><span class="line">var body &#x3D; &#39;&lt;html&gt;&#39;+</span><br><span class="line">&#39;&lt;head&gt;&#39;+</span><br><span class="line">&#39;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; &#39;+</span><br><span class="line">&#39;charset&#x3D;UTF-8&quot; &#x2F;&gt;&#39;+</span><br><span class="line">&#39;&lt;&#x2F;head&gt;&#39;+</span><br><span class="line">&#39;&lt;body&gt;&#39;+</span><br><span class="line">&#39;&lt;form action&#x3D;&quot;&#x2F;upload&quot; method&#x3D;&quot;post&quot;&gt;&#39;+</span><br><span class="line">&#39;&lt;textarea name&#x3D;&quot;text&quot; rows&#x3D;&quot;20&quot; cols&#x3D;&quot;60&quot;&gt;&lt;&#x2F;textarea&gt;&#39;+</span><br><span class="line">&#39;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit text&quot; &#x2F;&gt;&#39;+</span><br><span class="line">&#39;&lt;&#x2F;form&gt;&#39;+</span><br><span class="line">&#39;&lt;&#x2F;body&gt;&#39;+</span><br><span class="line">&#39;&lt;&#x2F;html&gt;&#39;;</span><br><span class="line">    </span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;html&quot;&#125;);</span><br><span class="line">    response.write(body);</span><br><span class="line">    response.end();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload(response)&#123;</span><br><span class="line">    console.log(&quot;Request handle &#39;upload&#39; was called.&quot;);</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello Upload&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">exports.start&#x3D;start;</span><br><span class="line">exports.upload&#x3D;upload;</span><br></pre></td></tr></table></figure>
<p>启动应用，即可看到简单的表单了，提交表单，会触发/upload 请求处理程序处理POST请求。</p>
<h4 id="处理-POST-请求"><a href="#处理-POST-请求" class="headerlink" title="处理 POST 请求"></a>处理 POST 请求</h4><p>一个简单的表单已经完成了，接下来就是需要实现当用户提交表单时，触发/upload 请求处理程序处理 POST 请求了。<br>这里，还需要注意一点，由于对于POST请求，用户可能会输入大量的内容，所以Node.js 会将 POST 数据拆分成很多小的数据块， 然后通过触发特定的事件，将这些小数据块传递给回调函数。当这些事件触发的时候，具体回调哪些函数需要通过在 request 对象上注册监听器（ listener） 来实现。</p>
<p> （1） 修改server.js文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> postData = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Request for &quot;</span> + pathname + <span class="string">&quot; received.&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        request.setEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        request.addListener(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">postDataChunk</span>) </span>&#123;</span><br><span class="line">            postData += postDataChunk;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Received POST data chunk &#x27;&quot;</span>+</span><br><span class="line">            postDataChunk + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        request.addListener(<span class="string">&quot;end&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            route(handle, pathname, response, postData);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Server has started.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">exports</span>.start = start;</span><br></pre></td></tr></table></figure>
<p>上述代码完成了三件事情：<br>①设置了接收数据的编码格式为UTF-8；<br>②注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给 postData 变量；<br>③我们将请求路由的调用移到 end 事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。同时还把 POST 数据传递给请求路由，因为这些数据，请求处理程序会用到。</p>
<p> （2） 修改 router.js文件：<br>要在/upload 页面，展示用户输入的内容，需要将 postData 传递给请求处理程序，因此对router.js 进行修改，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle,pathname,response,postData</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;About to route a request for&quot;</span>+pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> handle[pathname]==<span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        handle[pathname](response,postData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;No request handle found for&quot;</span>+pathname);</span><br><span class="line">        response.writeHead(<span class="number">404</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">        response.write(<span class="string">&quot;404 Not found&quot;</span>);</span><br><span class="line">        response.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.route=route;</span><br></pre></td></tr></table></figure>

<p> （3） 修改 requestHandlers.js：<br>为了实现将数据包含在对 upload 请求的响应中，对 requestHandlers.js进行修改，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var querystring &#x3D; require(&quot;querystring&quot;);</span><br><span class="line"></span><br><span class="line">function start(response, postData) &#123;</span><br><span class="line">    console.log(&quot;Request handler &#39;start&#39; was called.&quot;);</span><br><span class="line">    var body &#x3D; &#39;&lt;html&gt;&#39;+</span><br><span class="line">        &#39;&lt;head&gt;&#39;+</span><br><span class="line">        &#39;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; &#39;+</span><br><span class="line">        &#39;charset&#x3D;UTF-8&quot; &#x2F;&gt;&#39;+</span><br><span class="line">        &#39;&lt;&#x2F;head&gt;&#39;+</span><br><span class="line">        &#39;&lt;body&gt;&#39;+</span><br><span class="line">        &#39;&lt;form action&#x3D;&quot;&#x2F;upload&quot; method&#x3D;&quot;post&quot;&gt;&#39;+</span><br><span class="line">        &#39;&lt;textarea name&#x3D;&quot;text&quot; rows&#x3D;&quot;20&quot; cols&#x3D;&quot;60&quot;&gt;&lt;&#x2F;textarea&gt;&#39;+</span><br><span class="line">        &#39;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit text&quot; &#x2F;&gt;&#39;+</span><br><span class="line">        &#39;&lt;&#x2F;form&gt;&#39;+</span><br><span class="line">        &#39;&lt;&#x2F;body&gt;&#39;+</span><br><span class="line">        &#39;&lt;&#x2F;html&gt;&#39;;</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;html&quot;&#125;);</span><br><span class="line">    response.write(body);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload(response, postData) &#123;</span><br><span class="line">    console.log(&quot;Request handler &#39;upload&#39; was called.&quot;);</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;You&#39;ve sent the text: &quot;+</span><br><span class="line">    querystring.parse(postData).text);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start &#x3D; start;</span><br><span class="line">exports.upload &#x3D; upload;</span><br></pre></td></tr></table></figure>
<p>到此，一个简单的web应用已经完成了。启动应用，然后通过浏览器访问<br><a href="http://localhost:8888/start%EF%BC%8C">http://localhost:8888/start，</a> 在页面的文本框输入文本“hello world!”，点击提交按钮后，请求会被upload处理程序处理,然后在新的浏览器页面显示提交的内容：“You’ve sent the text: hello world!”。</p>
<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Node.js中的html代码以源码出现，而不能被解析。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>响应的 Content-Type属性 如果设置成 “text/plain”，表示以 <strong>文本形式</strong> 输出。只有将其设置成“text/html ”，才能让浏览器 <strong>解析</strong> html文档。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Vue.js</title>
    <url>/2017/03/04/%E5%88%9D%E8%AF%86Vue-js/</url>
    <content><![CDATA[<h2 id="Vue-js是什么？"><a href="#Vue-js是什么？" class="headerlink" title="Vue.js是什么？"></a>Vue.js是什么？</h2><p>&emsp;&emsp;<strong>Vue.js</strong>是一套构建用户界面的渐进式框架。<strong>Vue.js</strong>的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。<strong>Vue.js</strong> 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。</p>
<h2 id="从“Hello-world-”例子开启Vue之旅"><a href="#从“Hello-world-”例子开启Vue之旅" class="headerlink" title="从“Hello, world!”例子开启Vue之旅"></a>从“Hello, world!”例子开启Vue之旅</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	 &#123;&#123; message &#125;&#125; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F;通过构造函数 Vue 创建一个 Vue 的根实例</span><br><span class="line">	  var example &#x3D; new Vue(&#123;</span><br><span class="line">		    el: &#39;#example&#39;,</span><br><span class="line">		    data:&#123;</span><br><span class="line">		        message:&#39;hello world!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h2><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>&emsp;&emsp;在表单控件或者组件上创建双向绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">		&lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">		&lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">		&lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">	&lt;&#x2F;select&gt;</span><br><span class="line">	&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#example&#39;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		selected: &#39;&#39;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>&emsp;&emsp;根据其后表达式的<code>bool值</code>进行判断是否渲染该元素。常与<code>v-else-if/v-else</code>一起使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&lt;h1 v-if&#x3D;&quot;score &#x3D;&#x3D;&#x3D; &#39;100&#39;&quot;&gt;优秀&lt;&#x2F;h1&gt;</span><br><span class="line">	&lt;h1 v-else-if&#x3D;&quot;score &#x3D;&#x3D;&#x3D; &#39;100&#39;&quot;&gt;良好&lt;&#x2F;h1&gt;</span><br><span class="line">	&lt;h1 v-else&#x3D;&quot;score &#x3D;&#x3D;&#x3D; &#39;100&#39;&quot;&gt;及格&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#example&#39;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        score:&#39;100&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>&emsp;&emsp;跟v-if的用法大致一样，不同的是有 <code>v-show</code> 的元素会始终渲染并保持在 DOM 中。<code>v-show</code> 是简单的切换元素的 CSS 属性 display。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&lt;h1 v-show&#x3D;&quot;ok&quot;&gt;Hello!&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#example&#39;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		ok: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>&emsp;&emsp;用于响应地更新 HTML 特性。可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性，如style，class等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot; v-bind:style&#x3D;&quot;styleObject&quot;&gt;</span><br><span class="line">	哈哈哈</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#example&#39;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		styleObject:&#123;</span><br><span class="line">			color: &#39;blue&#39;,</span><br><span class="line">			fontSize: &#39;10px&#39;,</span><br><span class="line">			background: &#39;yellow&#39;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意，v-bind可以缩写成<code>：</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>&emsp;&emsp;用于监听指定元素的DOM事件，如点击事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;button v-on:click&#x3D;&quot;greet&quot;&gt;greet&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#example&#39;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		greet: function(event)&#123;</span><br><span class="line">			alert(&#39;hello vue.js!&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意，v-on可以缩写成<code>@</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>&emsp;&emsp;根据一组数组的选项列表进行渲染。<code>v-for</code> 指令需要以 <code>item in items</code>形式的特殊语法，其中<code>items</code> 是源数据数组，并且 <code>item</code> 是数组元素迭代的别名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  	&lt;li v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">  		&#123;&#123;item.message&#125;&#125;</span><br><span class="line">  	&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#example&#39;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		items: [</span><br><span class="line">			&#123;</span><br><span class="line">				message: &#39;红楼梦&#39;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				message: &#39;水浒传&#39;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				message: &#39;西游记&#39;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				message: &#39;三国演义&#39;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>v-for</code> 还支持一个可选的第二个参数为当前项的索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li v-for&#x3D;&quot;(item, index) in items&quot;&gt;</span><br><span class="line">			&#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">		&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">		el: &#39;#example&#39;,</span><br><span class="line">		data: &#123;</span><br><span class="line">		items: [</span><br><span class="line">			&#123; message: &#39;陈&#39; &#125;,</span><br><span class="line">			&#123; message: &#39;婷&#39; &#125;</span><br><span class="line">		]</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>&emsp;&emsp;模板中的表达式一般只用于简单的操作。如果在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 <code>Vue.js</code> 将绑定表达式限制为一个表达式，所以如果需要多于一个表达式的逻辑，应当使用计算属性。</p>
<h3 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&#123;&#123; fullName &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">	  el: &#39;#example&#39;,</span><br><span class="line">	  data: &#123;</span><br><span class="line">	    firstName: &#39;Foo&#39;,</span><br><span class="line">	    lastName: &#39;Bar&#39;</span><br><span class="line">	  &#125;,</span><br><span class="line">	computed: &#123;</span><br><span class="line">	    fullName: function () &#123;</span><br><span class="line">	      return this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="加入setter"><a href="#加入setter" class="headerlink" title="加入setter"></a>加入setter</h3><p>&emsp;&emsp;计算属性默认只有 <code>getter</code> ，可以根据需要提供一个 <code>setter</code>。如下例子，在控制台调用<code>vm.fullName = &#39;John Doe&#39;</code>时，<code>setter</code> 就会被调用。<code>vm.firstName</code>和<code>vm.lastName</code>也会有相应更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#example&#39;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		firstName: &#39;陈&#39;,</span><br><span class="line">		lastName: &#39;婷&#39;</span><br><span class="line">	&#125;,</span><br><span class="line">	computed: &#123;</span><br><span class="line">		fullName: &#123;</span><br><span class="line">		&#x2F;&#x2F; getter</span><br><span class="line">		get: function()&#123;</span><br><span class="line">			return this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">		&#125;,</span><br><span class="line">		&#x2F;&#x2F; setter</span><br><span class="line">		set: function(newValue)&#123;</span><br><span class="line">			var names &#x3D; newValue.split(&#39; &#39;)</span><br><span class="line">			this.firstName &#x3D; names[0]</span><br><span class="line">			this.lastName &#x3D; names[names.length - 1]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="计算属性-vs-method"><a href="#计算属性-vs-method" class="headerlink" title="计算属性 vs  method"></a>计算属性 vs  method</h3><p>&emsp;&emsp;<strong>计算属性</strong>与 <strong>method</strong> 的区别在于，计算属性根据它的依赖被缓存，即如果 <code>message</code> 没有被修改，下次 <code>get</code> 不会进行重复计算，而 <code>method</code> 则每次调用都会重新计算。这也意味着如 <code>Date.now()</code> 这样返回的计算属性会永远得不到更新。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>&emsp;&emsp;组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素;通过<code>Vue.component()</code>接口将大型应用拆分为各个组件，从而使代码更好具有维护性、复用性以及可读性。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>&emsp;&emsp;要注册一个组件，使用<code> Vue.component(tagName, options)</code>形式。组件在注册之后，便可以在父实例的模块中以自定义元素 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 的形式使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&lt;my-component&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册</span><br><span class="line">Vue.component(&#39;my-component&#39;,&#123;</span><br><span class="line">	template: &#39;&lt;div&gt;hello world!&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;创建根实例</span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#example&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件中的data必须是函数"><a href="#组件中的data必须是函数" class="headerlink" title="组件中的data必须是函数"></a>组件中的data必须是函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue 会在控制台发出警告，告诉你在组件中 data 必须是一个函数</span><br><span class="line">Vue.component(&#39;my-component&#39;,&#123;</span><br><span class="line">	template: &#39;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		message:&#39;hello world!&#39;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;data为一个函数，程序正常执行</span><br><span class="line">Vue.component(&#39;my-component&#39;,&#123;</span><br><span class="line">	template: &#39;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">	data: function()&#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			message: &#39;hello world!&#39;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><h4 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h4><p>&emsp;&emsp;每个组件都是相互隔离的，所以无法在子组件的<code>template</code>中引用父组件的数据。数据只能通过 <code>prop </code>传递。<code>prop</code> 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 <code>props </code>选项声明 <code>“prop”</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">&lt;!-- 传递props --&gt;</span><br><span class="line">	&lt;child message&#x3D;&quot;chen-xt&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;child&#39;,&#123;</span><br><span class="line">&#x2F;&#x2F;声明props</span><br><span class="line">		props: [&#39;message&#39;],</span><br><span class="line">		template: &#39;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">	&#125;)</span><br><span class="line">	var example &#x3D; new Vue(&#123;</span><br><span class="line">		el: &#39;#example&#39;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h4><p>&emsp;&emsp;子组件要把数据传递回去可以使用自定义事件。使用 $on(eventName) 监听事件，使用 $emit(eventName) 触发事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件通过$emit触发父组件的事件，$emit后面的参数是向父组件传参</span><br><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&lt;p&gt;&#123;&#123; total &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">	&lt;button-counter v-on:increment&#x3D;&quot;incrementTotal&quot;&gt;&lt;&#x2F;button-counter&gt;</span><br><span class="line">	&lt;button-counter v-on:increment&#x3D;&quot;incrementTotal&quot;&gt;&lt;&#x2F;button-counter&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;button-counter&#39;,&#123;</span><br><span class="line">		template: &#39;&lt;button v-on:click&#x3D;&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;&#x2F;button&gt;&#39;,</span><br><span class="line">		data: function()&#123;</span><br><span class="line">		return&#123;</span><br><span class="line">			counter: 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">		increment: function()&#123;</span><br><span class="line">			this.counter +&#x3D; 1</span><br><span class="line">			this.$emit(&#39;increment&#39;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">	el: &#39;#example&#39;,</span><br><span class="line">	data:&#123;</span><br><span class="line">		total: 0</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		incrementTotal:function()&#123;</span><br><span class="line">			this.total +&#x3D; 1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用Slots分发内容"><a href="#使用Slots分发内容" class="headerlink" title="使用Slots分发内容"></a>使用Slots分发内容</h3><p>&emsp;&emsp;内容分发指的是混合父组件的内容与子组件自己的模板。</p>
<h4 id="单个slot"><a href="#单个slot" class="headerlink" title="单个slot"></a>单个slot</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;我是子组件的标题&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;slot&gt;</span><br><span class="line">    只有在没有要分发的内容时才会显示。</span><br><span class="line">  &lt;&#x2F;slot&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;我是父组件的标题&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;my-component&gt;</span><br><span class="line">    &lt;p&gt;这是一些初始内容&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;这是更多的初始内容&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 渲染结果：--&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;我是父组件的标题&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是子组件的标题&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;这是一些初始内容&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;这是更多的初始内容&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="具名slot"><a href="#具名slot" class="headerlink" title="具名slot"></a>具名slot</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">      &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">      &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">      &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;app-layout&gt;</span><br><span class="line">    &lt;h1 slot&#x3D;&quot;header&quot;&gt;这里可能是一个页面标题&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;主要内容的一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;另一个主要段落。&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p slot&#x3D;&quot;footer&quot;&gt;这里有一些联系信息&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;app-layout&gt;</span><br><span class="line">&lt;!-- 渲染结果：--&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">      &lt;h1&gt;这里可能是一个页面标题&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">      &lt;p&gt;主要内容的一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;另一个主要段落。&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">      &lt;p&gt;这里有一些联系信息&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h2><h3 id="简单监听事件"><a href="#简单监听事件" class="headerlink" title="简单监听事件"></a>简单监听事件</h3><p>&emsp;&emsp;用 v-on 指令监听 DOM 事件来触发一些 JavaScript 代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	&lt;button v-on:click&#x3D;&quot;counter +&#x3D; 1&quot;&gt;减少 1&lt;&#x2F;button&gt;</span><br><span class="line">	&lt;p&gt;这个按钮被点击了 &#123;&#123; counter-10 &#125;&#125; 次。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#example&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">       counter: 10</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h3><p>&emsp;&emsp;当事件处理的逻辑很复杂的时候，可以将<code>v-on</code> 指令绑定到一个方法上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">     &lt;!-- &#96;show&#96; 是在下面定义的方法名 --&gt;</span><br><span class="line">	 &lt;button v-on:click&#x3D;&quot;show&quot;&gt;show&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"> var example &#x3D; new Vue(&#123;</span><br><span class="line">	  el: &#39;#example&#39;,</span><br><span class="line">	  data: &#123;</span><br><span class="line">	    name: &#39;chen-xt&#39;,</span><br><span class="line">	    message: &#39; &#39;</span><br><span class="line">	  &#125;,</span><br><span class="line">	  &#x2F;&#x2F; 在 &#96;methods&#96; 对象中定义方法</span><br><span class="line">	  methods: &#123;</span><br><span class="line">	    show: function (event) &#123;</span><br><span class="line">	      &#x2F;&#x2F; &#96;this&#96; 在方法里指当前 Vue 实例</span><br><span class="line">	      alert(&#39;Hello &#39; + this.name + &#39;!&#39;)</span><br><span class="line">	      </span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="内联处理器"><a href="#内联处理器" class="headerlink" title="内联处理器"></a>内联处理器</h3><p>&emsp;&emsp;当事件处理的逻辑很复杂的时候，除了将<code>v-on</code>指令绑定到一个方法上，还可以使用内联 JavaScript 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	  &lt;button v-on:click&#x3D;&quot;show(&#39;hi&#39;)&quot;&gt;Say hi&lt;&#x2F;button&gt;</span><br><span class="line">	  &lt;button v-on:click&#x3D;&quot;show(&#39;hello&#39;)&quot;&gt;Say hello&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D;new Vue(&#123;</span><br><span class="line">	  el: &#39;#example&#39;,</span><br><span class="line">	  methods: &#123;</span><br><span class="line">	    show: function (message) &#123;</span><br><span class="line">	      alert(message)</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">	 &lt;button v-on:click&#x3D;&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;</span><br><span class="line">		 Submit</span><br><span class="line">	 &lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var example &#x3D;new Vue(&#123;</span><br><span class="line">   el: &#39;#example&#39;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">   warn: function (message, event) &#123;</span><br><span class="line">      &#x2F;&#x2F; 访问原生事件对象</span><br><span class="line">      if (event) event.preventDefault()</span><br><span class="line">      alert(message)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>&emsp;&emsp;<code>Vue.js</code> 为<code> v-on</code> 提供了事件修饰符来处理 DOM 事件细节，。通过由点(.)表示的指令后缀来调用修饰符。</p>
<ul>
<li>.stop</li>
<li>.prevent</li>
<li>.capture</li>
<li>.self</li>
<li>.once<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class="line">&lt;div v-on:click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- click 事件至少触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>&emsp;&emsp;<code>Vue</code> 允许为<code>v-on</code>在监听键盘事件时添加按键修饰符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;</span><br><span class="line">&lt;input v-on:keyup.13&#x3D;&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;想记住所有的 keyCode 是很有难度的，因此Vue 为最常用的按键提供了别名，如下：</p>
<ul>
<li>.tab</li>
<li>.delete (捕获 “删除” 和 “退格” 键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Alt + C --&gt;</span><br><span class="line">&lt;input @keyup.alt.67&#x3D;&quot;clear&quot;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h2><h3 id="过渡的CSS类名"><a href="#过渡的CSS类名" class="headerlink" title="过渡的CSS类名"></a>过渡的CSS类名</h3><ol>
<li><strong>v-enter</strong>: &emsp;定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</li>
<li><strong>v-enter-active</strong>:&emsp; 定义进入过渡的结束状态。在元素被插入时生效，在 <code>transition/animation</code> 完成之后移除。</li>
<li><strong>v-leave</strong>: &emsp;定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</li>
<li><strong>v-leave-active</strong>:&emsp; 定义离开过渡的结束状态。在离开过渡被触发时生效，在 <code>transition/animation</code> 完成之后移除。</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;对于这些在 <code>enter/leave </code>过渡中切换的类名，<code>v-</code> 是这些类名的前缀。使用<code>&lt;transition name=&quot;my-transition&quot;&gt;</code>可以重置前缀，比如 <code>v-enter</code> 替换为 <code>my-transition-enter</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.slide-fade-enter-active &#123;</span><br><span class="line">  transition: all .3s ease;</span><br><span class="line">&#125;</span><br><span class="line">.slide-fade-leave-active &#123;</span><br><span class="line">  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);</span><br><span class="line">&#125;</span><br><span class="line">.slide-fade-enter, .slide-fade-leave-active &#123;</span><br><span class="line">  transform: translateX(10px);</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;show &#x3D; !show&quot;&gt;</span><br><span class="line">      Toggle </span><br><span class="line">  &lt;&#x2F;button&gt;</span><br><span class="line">  &lt;transition name&#x3D;&quot;slide-fade&quot;&gt;</span><br><span class="line">      &lt;p v-if&#x3D;&quot;show&quot;&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;transition&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	var example &#x3D; new Vue(&#123;</span><br><span class="line">		el: &#39;#example&#39;,</span><br><span class="line">		data: &#123;</span><br><span class="line">		show: true</span><br><span class="line">	   &#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>&emsp;&emsp; Vue.js 路由允许我们通过不同的 URL 访问不同的内容。Vue.js 路由需要载入 vue-router 库。<br>&emsp;&emsp; 下面是一个使用 Vue.js + vue-router 实现简单单页应用的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Hello 路由!&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">	    &lt;!-- 使用 router-link 组件来导航. --&gt;</span><br><span class="line">	    &lt;!-- 通过传入 &#96;to&#96; 属性指定链接. --&gt;</span><br><span class="line">	    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 &#96;&lt;a&gt;&#96; 标签 --&gt;</span><br><span class="line">	    &lt;router-link to&#x3D;&quot;&#x2F;foo&quot;&gt;Go to Foo&lt;&#x2F;router-link&gt;</span><br><span class="line">	    &lt;router-link to&#x3D;&quot;&#x2F;bar&quot;&gt;Go to Bar&lt;&#x2F;router-link&gt;</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br><span class="line">  &lt;!-- 路由出口：路由匹配到的组件将渲染在这里 --&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  定义（路由）组件。</span><br><span class="line">const Foo &#x3D; &#123; template: &#39;&lt;div&gt;foo&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line">const Bar &#x3D; &#123; template: &#39;&lt;div&gt;bar&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 定义路由：每个路由应该映射一个组件。</span><br><span class="line">const routes &#x3D; [</span><br><span class="line">    &#123; path: &#39;&#x2F;foo&#39;, component: Foo &#125;,</span><br><span class="line">    &#123; path: &#39;&#x2F;bar&#39;, component: Bar &#125;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;创建 router 实例，然后传 &#96;routes&#96; 配置</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">   routes &#x2F;&#x2F; （缩写）相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 创建和挂载根实例：要通过 router 配置参数注入路由，从而让整个应用都有路由功能</span><br><span class="line">const app &#x3D; new Vue(&#123;</span><br><span class="line">     router</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>&emsp;&emsp;把一个普通 Javascript 对象传给 Vue 实例的 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <code>Object.defineProperty</code>把这些属性全部转为 <code>getter/setter</code>。</p>
<h3 id="变化检测问题"><a href="#变化检测问题" class="headerlink" title="变化检测问题"></a>变化检测问题</h3><p>&emsp;&emsp; Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。所以可以使用 <code>Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">  a:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; vm.a 是响应的</span><br><span class="line">vm.b &#x3D; 2</span><br><span class="line">&#x2F;&#x2F; vm.b 是非响应的</span><br></pre></td></tr></table></figure>

<h3 id="声明响应式属性"><a href="#声明响应式属性" class="headerlink" title="声明响应式属性"></a>声明响应式属性</h3><p>&emsp;&emsp; 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，即使是一个空值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    &#x2F;&#x2F; 声明 message 为一个空值字符串</span><br><span class="line">    message: &#39;&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#39;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 之后设置 message </span><br><span class="line">vm.message &#x3D; &#39;Hello!&#39;</span><br></pre></td></tr></table></figure>

<h3 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h3><p>&emsp;&emsp;Vue.js 默认异步执行DOM更新 。每当观察到数据变化时，Vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来。如果一个 <code>watcher</code> 被多次触发，只会推入一次到队列中。等到下一次事件循环，Vue 将清空队列，只进行必要的 DOM 更新。<br>&emsp;&emsp;注意，当设置 <code>vm.someData = &#39;new value&#39;</code> 时，该组件不会立即重新渲染。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code> 。这样回调函数在 DOM 更新完成后就会调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;123&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message &#x3D; &#39;new message&#39; &#x2F;&#x2F; 更改数据</span><br><span class="line">vm.$el.textContent &#x3D;&#x3D;&#x3D; &#39;new message&#39; &#x2F;&#x2F; false</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  vm.$el.textContent &#x3D;&#x3D;&#x3D; &#39;new message&#39; &#x2F;&#x2F; true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://cn.vuejs.org/v2/guide/">Vue.js官方教程</a></li>
<li><a href="http://cn.vuejs.org/v2/api/">Vue.js API</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>git rabase 后,提交的commit消失,如何找回</title>
    <url>/2021/02/20/git-rabase-%E5%90%8E-%E6%8F%90%E4%BA%A4%E7%9A%84commit%E6%B6%88%E5%A4%B1-%E5%A6%82%E4%BD%95%E6%89%BE%E5%9B%9E/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;&emsp;在 执行 <code>git rebase</code> 操作时，如果存在冲突，使用 <code>git rebase --abort</code> 处理后，会发现 commit 的修改和记录都没有了。执行 <code>git log</code> 看不到记录(使用 <code>git rebase --skip</code> 处理，也有可能导致 commit 消失)。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li><p>执行<code>git reflog</code> 命令列出 log 信息，如下图<br><img src="/images/content/reflog.png" alt="截图"></p>
</li>
<li><p>使用消失的 commit 重新建立一个 branch，命名<code>bak</code><br><code> git checkout -b bak b670c33b</code><br>此时的新分支 bak 的 git log 记录就刚好在红色框那个点上</p>
</li>
<li><p>最后在新分支，重新提交合并，然后 push 上去就可以啦。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
